{"pages":[{"title":"about","text":"","link":"/about/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"archives","text":"","link":"/archives/index.html"},{"title":"","text":"$(document).ready(() => { const $button = $('#back-to-top'); const $footer = $('footer.footer'); const $mainColumn = $('.column-main'); const $leftSidebar = $('.column-left'); const $rightSidebar = $('.column-right'); let lastScrollTop = 0; const rightMargin = 20; const bottomMargin = 20; let lastState = null; const state = { base: { classname: 'card has-text-centered', left: '', width: 64, bottom: bottomMargin } }; state['desktop-hidden'] = Object.assign({}, state.base, { classname: state.base.classname + ' rise-up' }); state['desktop-visible'] = Object.assign({}, state['desktop-hidden'], { classname: state['desktop-hidden'].classname + ' fade-in' }); state['desktop-dock'] = Object.assign({}, state['desktop-visible'], { classname: state['desktop-visible'].classname + ' fade-in is-rounded', width: 40 }); state['mobile-hidden'] = Object.assign({}, state.base, { classname: state.base.classname + ' fade-in', right: rightMargin }); state['mobile-visible'] = Object.assign({}, state['mobile-hidden'], { classname: state['mobile-hidden'].classname + ' rise-up' }); function isStateEquals(prev, next) { return ![].concat(Object.keys(prev), Object.keys(next)).some(key => { return !Object.prototype.hasOwnProperty.call(prev, key) || !Object.prototype.hasOwnProperty.call(next, key) || next[key] !== prev[key]; }); } function applyState(state) { if (lastState !== null && isStateEquals(lastState, state)) { return; } $button.attr('class', state.classname); for (const prop in state) { if (prop === 'classname') { continue; } $button.css(prop, state[prop]); } lastState = state; } function isDesktop() { return window.innerWidth >= 1078; } function isTablet() { return window.innerWidth >= 768 && !isDesktop(); } function isScrollUp() { return $(window).scrollTop() < lastScrollTop && $(window).scrollTop() > 0; } function hasLeftSidebar() { return $leftSidebar.length > 0; } function hasRightSidebar() { return $rightSidebar.length > 0; } function getRightSidebarBottom() { if (!hasRightSidebar()) { return 0; } return Math.max.apply(null, $rightSidebar.find('.widget').map(function() { return $(this).offset().top + $(this).outerHeight(true); })); } function getScrollTop() { return $(window).scrollTop(); } function getScrollBottom() { return $(window).scrollTop() + $(window).height(); } function getButtonWidth() { return $button.outerWidth(true); } function getButtonHeight() { return $button.outerHeight(true); } function updateScrollTop() { lastScrollTop = $(window).scrollTop(); } function update() { // desktop mode or tablet mode with only right sidebar enabled if (isDesktop() || (isTablet() && !hasLeftSidebar() && hasRightSidebar())) { let nextState; const padding = ($mainColumn.outerWidth() - $mainColumn.width()) / 2; const maxLeft = $(window).width() - getButtonWidth() - rightMargin; const maxBottom = $footer.offset().top + (getButtonHeight() / 2) + bottomMargin; if (getScrollTop() === 0 || getScrollBottom() < getRightSidebarBottom() + padding + getButtonHeight()) { nextState = state['desktop-hidden']; } else if (getScrollBottom() < maxBottom) { nextState = state['desktop-visible']; } else { nextState = Object.assign({}, state['desktop-dock'], { bottom: getScrollBottom() - maxBottom + bottomMargin }); } const left = $mainColumn.offset().left + $mainColumn.outerWidth() + padding; nextState = Object.assign({}, nextState, { left: Math.min(left, maxLeft) }); applyState(nextState); } else { // mobile and tablet mode if (!isScrollUp()) { applyState(state['mobile-hidden']); } else { applyState(state['mobile-visible']); } updateScrollTop(); } } update(); $(window).resize(update); $(window).scroll(update); $('#back-to-top').on('click', () => { if (CSS && CSS.supports && CSS.supports('(scroll-behavior: smooth)')) { window.scroll({ top: 0, behavior: 'smooth' }); } else { $('body, html').animate({ scrollTop: 0 }, 400); } }); });","link":"/js/back_to_top.js"},{"title":"","text":"(function() { function $() { return Array.prototype.slice.call(document.querySelectorAll.apply(document, arguments)); } // copy widgets in the right column, when exist, to the bottom of the left column if ($('.columns .column-right').length && $('.columns .column-right-shadow').length && !$('.columns .column-right-shadow')[0].children.length) { for (const child of $('.columns .column-right')[0].children) { $('.columns .column-right-shadow')[0].append(child.cloneNode(true)); } } }());","link":"/js/column.js"},{"title":"","text":"(function() { function $() { return Array.prototype.slice.call(document.querySelectorAll.apply(document, arguments)); } $('body > .navbar, body > .section, body > .footer').forEach(element => { element.style.transition = '0s'; element.style.opacity = '0'; }); document.querySelector('body > .navbar').style.transform = 'translateY(-100px)'; [ '.column-main > .card, .column-main > .pagination, .column-main > .post-navigation', '.column-left > .card, .column-right-shadow > .card', '.column-right > .card' ].forEach(selector => { $(selector).forEach(element => { element.style.transition = '0s'; element.style.opacity = '0'; element.style.transform = 'scale(0.8)'; element.style.transformOrigin = 'center top'; }); }); setTimeout(() => { $('body > .navbar, body > .section, body > .footer').forEach(element => { element.style.opacity = '1'; element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'; }); document.querySelector('body > .navbar').style.transform = 'translateY(0)'; [ '.column-main > .card, .column-main > .pagination, .column-main > .post-navigation', '.column-left > .card, .column-right-shadow > .card', '.column-right > .card' ].forEach(selector => { let i = 1; $(selector).forEach(element => { setTimeout(() => { element.style.opacity = '1'; element.style.transform = ''; element.style.transition = 'opacity 0.3s ease-out, transform 0.3s ease-out'; }, i * 100); i++; }); }); }); }());","link":"/js/animation.js"},{"title":"","text":"/* eslint-disable node/no-unsupported-features/node-builtins */ (function($, moment, ClipboardJS, config) { $('.article img:not(\".not-gallery-item\")').each(function() { // wrap images with link and add caption if possible if ($(this).parent('a').length === 0) { $(this).wrap(''); if (this.alt) { $(this).after('' + this.alt + ''); } } }); if (typeof $.fn.lightGallery === 'function') { $('.article').lightGallery({ selector: '.gallery-item' }); } if (typeof $.fn.justifiedGallery === 'function') { if ($('.justified-gallery > p > .gallery-item').length) { $('.justified-gallery > p > .gallery-item').unwrap(); } $('.justified-gallery').justifiedGallery(); } if (typeof moment === 'function') { $('.article-meta time').each(function() { $(this).text(moment($(this).attr('datetime')).fromNow()); }); } $('.article > .content > table').each(function() { if ($(this).width() > $(this).parent().width()) { $(this).wrap(''); } }); function adjustNavbar() { const navbarWidth = $('.navbar-main .navbar-start').outerWidth() + $('.navbar-main .navbar-end').outerWidth(); if ($(document).outerWidth() < navbarWidth) { $('.navbar-main .navbar-menu').addClass('justify-content-start'); } else { $('.navbar-main .navbar-menu').removeClass('justify-content-start'); } } adjustNavbar(); $(window).resize(adjustNavbar); function toggleFold(codeBlock, isFolded) { const $toggle = $(codeBlock).find('.fold i'); !isFolded ? $(codeBlock).removeClass('folded') : $(codeBlock).addClass('folded'); !isFolded ? $toggle.removeClass('fa-angle-right') : $toggle.removeClass('fa-angle-down'); !isFolded ? $toggle.addClass('fa-angle-down') : $toggle.addClass('fa-angle-right'); } function createFoldButton(fold) { return '' + (fold === 'unfolded' ? '' : '') + ''; } $('figure.highlight table').wrap(''); if (typeof config !== 'undefined' && typeof config.article !== 'undefined' && typeof config.article.highlight !== 'undefined') { $('figure.highlight').addClass('hljs'); $('figure.highlight .code .line span').each(function() { const classes = $(this).attr('class').split(/\\s+/); if (classes.length === 1) { $(this).addClass('hljs-' + classes[0]); $(this).removeClass(classes[0]); } }); const clipboard = config.article.highlight.clipboard; const fold = config.article.highlight.fold.trim(); $('figure.highlight').each(function() { if ($(this).find('figcaption').length) { $(this).find('figcaption').addClass('level is-mobile'); $(this).find('figcaption').append(''); $(this).find('figcaption').append(''); $(this).find('figcaption div.level-left').append($(this).find('figcaption').find('span')); $(this).find('figcaption div.level-right').append($(this).find('figcaption').find('a')); } else { if (clipboard || fold) { $(this).prepend(''); } } }); if (typeof ClipboardJS !== 'undefined' && clipboard) { $('figure.highlight').each(function() { const id = 'code-' + Date.now() + (Math.random() * 1000 | 0); const button = ''; $(this).attr('id', id); $(this).find('figcaption div.level-right').append(button); }); new ClipboardJS('.highlight .copy'); // eslint-disable-line no-new } if (fold) { $('figure.highlight').each(function() { if ($(this).find('figcaption').find('span').length > 0) { const span = $(this).find('figcaption').find('span'); if (span[0].innerText.indexOf('>folded') > -1) { span[0].innerText = span[0].innerText.replace('>folded', ''); $(this).find('figcaption div.level-left').prepend(createFoldButton('folded')); toggleFold(this, true); return; } } $(this).find('figcaption div.level-left').prepend(createFoldButton(fold)); toggleFold(this, fold === 'folded'); }); $('figure.highlight figcaption .fold').click(function() { const $code = $(this).closest('figure.highlight'); toggleFold($code.eq(0), !$code.hasClass('folded')); }); } } const $toc = $('#toc'); if ($toc.length > 0) { const $mask = $(''); $mask.attr('id', 'toc-mask'); $('body').append($mask); function toggleToc() { // eslint-disable-line no-inner-declarations $toc.toggleClass('is-active'); $mask.toggleClass('is-active'); } $toc.on('click', toggleToc); $mask.on('click', toggleToc); $('.navbar-main .catalogue').on('click', toggleToc); } }(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings));","link":"/js/main.js"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"schedule","text":"","link":"/schedule/index.html"},{"title":"sitemap","text":"","link":"/sitemap/index.html"},{"title":"","text":"\"use strict\"; function updateCoords(e) { pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top } function setParticuleDirection(e) { var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return { x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) } } function createParticule(e, t) { var a = {}; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() { ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() }, a } function createCircle(e, t) { var a = {}; return a.x = e, a.y = t, a.color = \"#F00\", a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() { ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 }, a } function renderParticule(e) { for (var t = 0; t < e.animatables.length; t++) { e.animatables[t].target.draw() } } function animateParticules(e, t) { for (var a = createCircle(e, t), n = [], i = 0; i < numberOfParticules; i++) { n.push(createParticule(e, t)) } anime.timeline().add({ targets: n, x: function(e) { return e.endPos.x }, y: function(e) { return e.endPos.y }, radius: 0.1, duration: anime.random(1200, 1800), easing: \"easeOutExpo\", update: renderParticule }).add({ targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: { value: 0, easing: \"linear\", duration: anime.random(600, 800) }, duration: anime.random(1200, 1800), easing: \"easeOutExpo\", update: renderParticule, offset: 0 }) } function debounce(e, t) { var a; return function() { var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() { e.apply(n, i) }, t) } } var canvasEl = document.querySelector(\".fireworks\"); if (canvasEl) { var ctx = canvasEl.getContext(\"2d\"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = \"mousedown\", colors = [\"#FF1461\", \"#18FF92\", \"#5A87FF\", \"#FBF38C\"], setCanvasSize = debounce(function() { canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + \"px\", canvasEl.style.height = window.innerHeight + \"px\", canvasEl.getContext(\"2d\").scale(2, 2) }, 500), render = anime({ duration: 1 / 0, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) } }); document.addEventListener(tap, function(e) { \"sidebar\" !== e.target.id && \"toggle-sidebar\" !== e.target.id && \"A\" !== e.target.nodeName && \"IMG\" !== e.target.nodeName && (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) }, !1), setCanvasSize(), window.addEventListener(\"resize\", setCanvasSize, !1) } \"use strict\"; function updateCoords(e) { pointerX = (e.clientX || e.touches[0].clientX) - canvasEl.getBoundingClientRect().left, pointerY = e.clientY || e.touches[0].clientY - canvasEl.getBoundingClientRect().top } function setParticuleDirection(e) { var t = anime.random(0, 360) * Math.PI / 180, a = anime.random(50, 180), n = [-1, 1][anime.random(0, 1)] * a; return { x: e.x + n * Math.cos(t), y: e.y + n * Math.sin(t) } } function createParticule(e, t) { var a = {}; return a.x = e, a.y = t, a.color = colors[anime.random(0, colors.length - 1)], a.radius = anime.random(16, 32), a.endPos = setParticuleDirection(a), a.draw = function() { ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.fillStyle = a.color, ctx.fill() }, a } function createCircle(e, t) { var a = {}; return a.x = e, a.y = t, a.color = \"#F00\", a.radius = 0.1, a.alpha = 0.5, a.lineWidth = 6, a.draw = function() { ctx.globalAlpha = a.alpha, ctx.beginPath(), ctx.arc(a.x, a.y, a.radius, 0, 2 * Math.PI, !0), ctx.lineWidth = a.lineWidth, ctx.strokeStyle = a.color, ctx.stroke(), ctx.globalAlpha = 1 }, a } function renderParticule(e) { for (var t = 0; t < e.animatables.length; t++) { e.animatables[t].target.draw() } } function animateParticules(e, t) { for (var a = createCircle(e, t), n = [], i = 0; i < numberOfParticules; i++) { n.push(createParticule(e, t)) } anime.timeline().add({ targets: n, x: function(e) { return e.endPos.x }, y: function(e) { return e.endPos.y }, radius: 0.1, duration: anime.random(1200, 1800), easing: \"easeOutExpo\", update: renderParticule }).add({ targets: a, radius: anime.random(80, 160), lineWidth: 0, alpha: { value: 0, easing: \"linear\", duration: anime.random(600, 800) }, duration: anime.random(1200, 1800), easing: \"easeOutExpo\", update: renderParticule, offset: 0 }) } function debounce(e, t) { var a; return function() { var n = this, i = arguments; clearTimeout(a), a = setTimeout(function() { e.apply(n, i) }, t) } } var canvasEl = document.querySelector(\".fireworks\"); if (canvasEl) { var ctx = canvasEl.getContext(\"2d\"), numberOfParticules = 30, pointerX = 0, pointerY = 0, tap = \"mousedown\", colors = [\"#FF1461\", \"#18FF92\", \"#5A87FF\", \"#FBF38C\"], setCanvasSize = debounce(function() { canvasEl.width = 2 * window.innerWidth, canvasEl.height = 2 * window.innerHeight, canvasEl.style.width = window.innerWidth + \"px\", canvasEl.style.height = window.innerHeight + \"px\", canvasEl.getContext(\"2d\").scale(2, 2) }, 500), render = anime({ duration: 1 / 0, update: function() { ctx.clearRect(0, 0, canvasEl.width, canvasEl.height) } }); document.addEventListener(tap, function(e) { \"sidebar\" !== e.target.id && \"toggle-sidebar\" !== e.target.id && \"A\" !== e.target.nodeName && \"IMG\" !== e.target.nodeName && (render.play(), updateCoords(e), animateParticules(pointerX, pointerY)) }, !1), setCanvasSize(), window.addEventListener(\"resize\", setCanvasSize, !1) };","link":"/js/cursor/explosion.js"},{"title":"","text":"class Circle { constructor({ origin, speed, color, angle, context }) { this.origin = origin this.position = { ...this.origin } this.color = color this.speed = speed this.angle = angle this.context = context this.renderCount = 0 } draw() { this.context.fillStyle = this.color this.context.beginPath() this.context.arc(this.position.x, this.position.y, 2, 0, Math.PI * 2) this.context.fill() } move() { this.position.x = (Math.sin(this.angle) * this.speed) + this.position.x this.position.y = (Math.cos(this.angle) * this.speed) + this.position.y + (this.renderCount * 0.3) this.renderCount++ } } class Boom { constructor ({ origin, context, circleCount = 16, area }) { this.origin = origin this.context = context this.circleCount = circleCount this.area = area this.stop = false this.circles = [] } randomArray(range) { const length = range.length const randomIndex = Math.floor(length * Math.random()) return range[randomIndex] } randomColor() { const range = ['8', '9', 'A', 'B', 'C', 'D', 'E', 'F'] return '#' + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) + this.randomArray(range) } randomRange(start, end) { return (end - start) * Math.random() + start } init() { for(let i = 0; i < this.circleCount; i++) { const circle = new Circle({ context: this.context, origin: this.origin, color: this.randomColor(), angle: this.randomRange(Math.PI - 1, Math.PI + 1), speed: this.randomRange(1, 6) }) this.circles.push(circle) } } move() { this.circles.forEach((circle, index) => { if (circle.position.x > this.area.width || circle.position.y > this.area.height) { return this.circles.splice(index, 1) } circle.move() }) if (this.circles.length == 0) { this.stop = true } } draw() { this.circles.forEach(circle => circle.draw()) } } class CursorSpecialEffects { constructor() { this.computerCanvas = document.createElement('canvas') this.renderCanvas = document.createElement('canvas') this.computerContext = this.computerCanvas.getContext('2d') this.renderContext = this.renderCanvas.getContext('2d') this.globalWidth = window.innerWidth this.globalHeight = window.innerHeight this.booms = [] this.running = false } handleMouseDown(e) { const boom = new Boom({ origin: { x: e.clientX, y: e.clientY }, context: this.computerContext, area: { width: this.globalWidth, height: this.globalHeight } }) boom.init() this.booms.push(boom) this.running || this.run() } handlePageHide() { this.booms = [] this.running = false } init() { const style = this.renderCanvas.style style.position = 'fixed' style.top = style.left = 0 style.zIndex = '999999999999999999999999999999999999999999' style.pointerEvents = 'none' style.width = this.renderCanvas.width = this.computerCanvas.width = this.globalWidth style.height = this.renderCanvas.height = this.computerCanvas.height = this.globalHeight document.body.append(this.renderCanvas) window.addEventListener('mousedown', this.handleMouseDown.bind(this)) window.addEventListener('pagehide', this.handlePageHide.bind(this)) } run() { this.running = true if (this.booms.length == 0) { return this.running = false } requestAnimationFrame(this.run.bind(this)) this.computerContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.renderContext.clearRect(0, 0, this.globalWidth, this.globalHeight) this.booms.forEach((boom, index) => { if (boom.stop) { return this.booms.splice(index, 1) } boom.move() boom.draw() }) this.renderContext.drawImage(this.computerCanvas, 0, 0, this.globalWidth, this.globalHeight) } } const cursorSpecialEffects = new CursorSpecialEffects() cursorSpecialEffects.init()","link":"/js/cursor/fireworks.js"},{"title":"","text":"var a_idx = 0; jQuery(document).ready(function($) { $(\"body\").click(function(e) { var a = new Array(\"喜欢我\", \"不喜欢我\"); var $i = $(\"\").text(a[a_idx]); var x = e.pageX, y = e.pageY; $i.css({ \"z-index\": 99999, \"top\": y - 28, \"left\": x - a[a_idx].length * 8, \"position\": \"absolute\", \"color\": \"#ff7a45\" }); $(\"body\").append($i); $i.animate({ \"top\": y - 180, \"opacity\": 0 }, 1500, function() { $i.remove(); }); a_idx = (a_idx + 1) % a.length; }); });","link":"/js/cursor/text.js"},{"title":"","text":"!function(e,t,a){function n(){c(\".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}\"),o(),r()}function r(){for(var e=0;e","link":"/js/cursor/love.js"},{"title":"","text":"var defaultEncoding = 2; // 网站默认语言，1: 繁體中文, 2: 简体中文 var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0 var cookieDomain = \"https://tding.top/\"; //更改为你的博客网址 var msgToTraditionalChinese = \"繁體\"; //此处可以更改为你想要显示的文字 var msgToSimplifiedChinese = \"简体\"; //同上，但两处均不建议更改 var translateButtonId = \"translateLink\"; //默认互换id var currentEncoding = defaultEncoding; var targetEncodingCookie = \"targetEncoding\" + cookieDomain.replace(/\\./g, \"\"); var targetEncoding = (getCookie(targetEncodingCookie) == null ? defaultEncoding: getCookie(targetEncodingCookie)); var translateButtonObject; function translateText(txt) { if (txt == \"\" || txt == null) return \"\"; if (currentEncoding == 1 && targetEncoding == 2) return Simplized(txt); else if (currentEncoding == 2 && targetEncoding == 1) return Traditionalized(txt); else return txt } function translateBody(fobj) { if (typeof(fobj) == \"object\") var objs = fobj.childNodes; else var objs = document.body.childNodes; for (var i = 0; i < objs.length; i++) { var obj = objs.item(i); if (\"||BR|HR|TEXTAREA|\".indexOf(\"|\" + obj.tagName + \"|\") > 0 || obj == translateButtonObject) continue; if (obj.title != \"\" && obj.title != null) obj.title = translateText(obj.title); if (obj.alt != \"\" && obj.alt != null) obj.alt = translateText(obj.alt); if (obj.tagName == \"INPUT\" && obj.value != \"\" && obj.type != \"text\" && obj.type != \"hidden\") obj.value = translateText(obj.value); if (obj.nodeType == 3) obj.data = translateText(obj.data); else translateBody(obj) } } function translatePage() { if (targetEncoding == 1) { currentEncoding = 1; targetEncoding = 2; translateButtonObject.innerHTML = msgToTraditionalChinese; setCookie(targetEncodingCookie, targetEncoding, 7); translateBody() } else if (targetEncoding == 2) { currentEncoding = 2; targetEncoding = 1; translateButtonObject.innerHTML = msgToSimplifiedChinese; setCookie(targetEncodingCookie, targetEncoding, 7); translateBody() } } function JTPYStr() { return '万与丑专业丛东丝丢两严丧个丬丰临为丽举么义乌乐乔习乡书买乱争于亏云亘亚产亩亲亵亸亿仅从仑仓仪们价众优伙会伛伞伟传伤伥伦伧伪伫体余佣佥侠侣侥侦侧侨侩侪侬俣俦俨俩俪俭债倾偬偻偾偿傥傧储傩儿兑兖党兰关兴兹养兽冁内冈册写军农冢冯冲决况冻净凄凉凌减凑凛几凤凫凭凯击凼凿刍划刘则刚创删别刬刭刽刿剀剂剐剑剥剧劝办务劢动励劲劳势勋勐勚匀匦匮区医华协单卖卢卤卧卫却卺厂厅历厉压厌厍厕厢厣厦厨厩厮县参叆叇双发变叙叠叶号叹叽吁后吓吕吗吣吨听启吴呒呓呕呖呗员呙呛呜咏咔咙咛咝咤咴咸哌响哑哒哓哔哕哗哙哜哝哟唛唝唠唡唢唣唤唿啧啬啭啮啰啴啸喷喽喾嗫呵嗳嘘嘤嘱噜噼嚣嚯团园囱围囵国图圆圣圹场坂坏块坚坛坜坝坞坟坠垄垅垆垒垦垧垩垫垭垯垱垲垴埘埙埚埝埯堑堕塆墙壮声壳壶壸处备复够头夸夹夺奁奂奋奖奥妆妇妈妩妪妫姗姜娄娅娆娇娈娱娲娴婳婴婵婶媪嫒嫔嫱嬷孙学孪宁宝实宠审宪宫宽宾寝对寻导寿将尔尘尧尴尸尽层屃屉届属屡屦屿岁岂岖岗岘岙岚岛岭岳岽岿峃峄峡峣峤峥峦崂崃崄崭嵘嵚嵛嵝嵴巅巩巯币帅师帏帐帘帜带帧帮帱帻帼幂幞干并广庄庆庐庑库应庙庞废庼廪开异弃张弥弪弯弹强归当录彟彦彻径徕御忆忏忧忾怀态怂怃怄怅怆怜总怼怿恋恳恶恸恹恺恻恼恽悦悫悬悭悯惊惧惨惩惫惬惭惮惯愍愠愤愦愿慑慭憷懑懒懔戆戋戏戗战戬户扎扑扦执扩扪扫扬扰抚抛抟抠抡抢护报担拟拢拣拥拦拧拨择挂挚挛挜挝挞挟挠挡挢挣挤挥挦捞损捡换捣据捻掳掴掷掸掺掼揸揽揿搀搁搂搅携摄摅摆摇摈摊撄撑撵撷撸撺擞攒敌敛数斋斓斗斩断无旧时旷旸昙昼昽显晋晒晓晔晕晖暂暧札术朴机杀杂权条来杨杩杰极构枞枢枣枥枧枨枪枫枭柜柠柽栀栅标栈栉栊栋栌栎栏树栖样栾桊桠桡桢档桤桥桦桧桨桩梦梼梾检棂椁椟椠椤椭楼榄榇榈榉槚槛槟槠横樯樱橥橱橹橼檐檩欢欤欧歼殁殇残殒殓殚殡殴毁毂毕毙毡毵氇气氢氩氲汇汉污汤汹沓沟没沣沤沥沦沧沨沩沪沵泞泪泶泷泸泺泻泼泽泾洁洒洼浃浅浆浇浈浉浊测浍济浏浐浑浒浓浔浕涂涌涛涝涞涟涠涡涢涣涤润涧涨涩淀渊渌渍渎渐渑渔渖渗温游湾湿溃溅溆溇滗滚滞滟滠满滢滤滥滦滨滩滪漤潆潇潋潍潜潴澜濑濒灏灭灯灵灾灿炀炉炖炜炝点炼炽烁烂烃烛烟烦烧烨烩烫烬热焕焖焘煅煳熘爱爷牍牦牵牺犊犟状犷犸犹狈狍狝狞独狭狮狯狰狱狲猃猎猕猡猪猫猬献獭玑玙玚玛玮环现玱玺珉珏珐珑珰珲琎琏琐琼瑶瑷璇璎瓒瓮瓯电画畅畲畴疖疗疟疠疡疬疮疯疱疴痈痉痒痖痨痪痫痴瘅瘆瘗瘘瘪瘫瘾瘿癞癣癫癯皑皱皲盏盐监盖盗盘眍眦眬着睁睐睑瞒瞩矫矶矾矿砀码砖砗砚砜砺砻砾础硁硅硕硖硗硙硚确硷碍碛碜碱碹磙礼祎祢祯祷祸禀禄禅离秃秆种积称秽秾稆税稣稳穑穷窃窍窑窜窝窥窦窭竖竞笃笋笔笕笺笼笾筑筚筛筜筝筹签简箓箦箧箨箩箪箫篑篓篮篱簖籁籴类籼粜粝粤粪粮糁糇紧絷纟纠纡红纣纤纥约级纨纩纪纫纬纭纮纯纰纱纲纳纴纵纶纷纸纹纺纻纼纽纾线绀绁绂练组绅细织终绉绊绋绌绍绎经绐绑绒结绔绕绖绗绘给绚绛络绝绞统绠绡绢绣绤绥绦继绨绩绪绫绬续绮绯绰绱绲绳维绵绶绷绸绹绺绻综绽绾绿缀缁缂缃缄缅缆缇缈缉缊缋缌缍缎缏缐缑缒缓缔缕编缗缘缙缚缛缜缝缞缟缠缡缢缣缤缥缦缧缨缩缪缫缬缭缮缯缰缱缲缳缴缵罂网罗罚罢罴羁羟羡翘翙翚耢耧耸耻聂聋职聍联聩聪肃肠肤肷肾肿胀胁胆胜胧胨胪胫胶脉脍脏脐脑脓脔脚脱脶脸腊腌腘腭腻腼腽腾膑臜舆舣舰舱舻艰艳艹艺节芈芗芜芦苁苇苈苋苌苍苎苏苘苹茎茏茑茔茕茧荆荐荙荚荛荜荞荟荠荡荣荤荥荦荧荨荩荪荫荬荭荮药莅莜莱莲莳莴莶获莸莹莺莼萚萝萤营萦萧萨葱蒇蒉蒋蒌蓝蓟蓠蓣蓥蓦蔷蔹蔺蔼蕲蕴薮藁藓虏虑虚虫虬虮虽虾虿蚀蚁蚂蚕蚝蚬蛊蛎蛏蛮蛰蛱蛲蛳蛴蜕蜗蜡蝇蝈蝉蝎蝼蝾螀螨蟏衅衔补衬衮袄袅袆袜袭袯装裆裈裢裣裤裥褛褴襁襕见观觃规觅视觇览觉觊觋觌觍觎觏觐觑觞触觯詟誉誊讠计订讣认讥讦讧讨让讪讫训议讯记讱讲讳讴讵讶讷许讹论讻讼讽设访诀证诂诃评诅识诇诈诉诊诋诌词诎诏诐译诒诓诔试诖诗诘诙诚诛诜话诞诟诠诡询诣诤该详诧诨诩诪诫诬语诮误诰诱诲诳说诵诶请诸诹诺读诼诽课诿谀谁谂调谄谅谆谇谈谊谋谌谍谎谏谐谑谒谓谔谕谖谗谘谙谚谛谜谝谞谟谠谡谢谣谤谥谦谧谨谩谪谫谬谭谮谯谰谱谲谳谴谵谶谷豮贝贞负贠贡财责贤败账货质贩贪贫贬购贮贯贰贱贲贳贴贵贶贷贸费贺贻贼贽贾贿赀赁赂赃资赅赆赇赈赉赊赋赌赍赎赏赐赑赒赓赔赕赖赗赘赙赚赛赜赝赞赟赠赡赢赣赪赵赶趋趱趸跃跄跖跞践跶跷跸跹跻踊踌踪踬踯蹑蹒蹰蹿躏躜躯车轧轨轩轪轫转轭轮软轰轱轲轳轴轵轶轷轸轹轺轻轼载轾轿辀辁辂较辄辅辆辇辈辉辊辋辌辍辎辏辐辑辒输辔辕辖辗辘辙辚辞辩辫边辽达迁过迈运还这进远违连迟迩迳迹适选逊递逦逻遗遥邓邝邬邮邹邺邻郁郄郏郐郑郓郦郧郸酝酦酱酽酾酿释里鉅鉴銮錾钆钇针钉钊钋钌钍钎钏钐钑钒钓钔钕钖钗钘钙钚钛钝钞钟钠钡钢钣钤钥钦钧钨钩钪钫钬钭钮钯钰钱钲钳钴钵钶钷钸钹钺钻钼钽钾钿铀铁铂铃铄铅铆铈铉铊铋铍铎铏铐铑铒铕铗铘铙铚铛铜铝铞铟铠铡铢铣铤铥铦铧铨铪铫铬铭铮铯铰铱铲铳铴铵银铷铸铹铺铻铼铽链铿销锁锂锃锄锅锆锇锈锉锊锋锌锍锎锏锐锑锒锓锔锕锖锗错锚锜锞锟锠锡锢锣锤锥锦锨锩锫锬锭键锯锰锱锲锳锴锵锶锷锸锹锺锻锼锽锾锿镀镁镂镃镆镇镈镉镊镌镍镎镏镐镑镒镕镖镗镙镚镛镜镝镞镟镠镡镢镣镤镥镦镧镨镩镪镫镬镭镮镯镰镱镲镳镴镶长门闩闪闫闬闭问闯闰闱闲闳间闵闶闷闸闹闺闻闼闽闾闿阀阁阂阃阄阅阆阇阈阉阊阋阌阍阎阏阐阑阒阓阔阕阖阗阘阙阚阛队阳阴阵阶际陆陇陈陉陕陧陨险随隐隶隽难雏雠雳雾霁霉霭靓静靥鞑鞒鞯鞴韦韧韨韩韪韫韬韵页顶顷顸项顺须顼顽顾顿颀颁颂颃预颅领颇颈颉颊颋颌颍颎颏颐频颒颓颔颕颖颗题颙颚颛颜额颞颟颠颡颢颣颤颥颦颧风飏飐飑飒飓飔飕飖飗飘飙飚飞飨餍饤饥饦饧饨饩饪饫饬饭饮饯饰饱饲饳饴饵饶饷饸饹饺饻饼饽饾饿馀馁馂馃馄馅馆馇馈馉馊馋馌馍馎馏馐馑馒馓馔馕马驭驮驯驰驱驲驳驴驵驶驷驸驹驺驻驼驽驾驿骀骁骂骃骄骅骆骇骈骉骊骋验骍骎骏骐骑骒骓骔骕骖骗骘骙骚骛骜骝骞骟骠骡骢骣骤骥骦骧髅髋髌鬓魇魉鱼鱽鱾鱿鲀鲁鲂鲄鲅鲆鲇鲈鲉鲊鲋鲌鲍鲎鲏鲐鲑鲒鲓鲔鲕鲖鲗鲘鲙鲚鲛鲜鲝鲞鲟鲠鲡鲢鲣鲤鲥鲦鲧鲨鲩鲪鲫鲬鲭鲮鲯鲰鲱鲲鲳鲴鲵鲶鲷鲸鲹鲺鲻鲼鲽鲾鲿鳀鳁鳂鳃鳄鳅鳆鳇鳈鳉鳊鳋鳌鳍鳎鳏鳐鳑鳒鳓鳔鳕鳖鳗鳘鳙鳛鳜鳝鳞鳟鳠鳡鳢鳣鸟鸠鸡鸢鸣鸤鸥鸦鸧鸨鸩鸪鸫鸬鸭鸮鸯鸰鸱鸲鸳鸴鸵鸶鸷鸸鸹鸺鸻鸼鸽鸾鸿鹀鹁鹂鹃鹄鹅鹆鹇鹈鹉鹊鹋鹌鹍鹎鹏鹐鹑鹒鹓鹔鹕鹖鹗鹘鹚鹛鹜鹝鹞鹟鹠鹡鹢鹣鹤鹥鹦鹧鹨鹩鹪鹫鹬鹭鹯鹰鹱鹲鹳鹴鹾麦麸黄黉黡黩黪黾鼋鼌鼍鼗鼹齄齐齑齿龀龁龂龃龄龅龆龇龈龉龊龋龌龙龚龛龟志制咨只里系范松没尝尝闹面准钟别闲干尽脏拼' } function FTPYStr() { return '萬與醜專業叢東絲丟兩嚴喪個爿豐臨為麗舉麼義烏樂喬習鄉書買亂爭於虧雲亙亞產畝親褻嚲億僅從侖倉儀們價眾優夥會傴傘偉傳傷倀倫傖偽佇體餘傭僉俠侶僥偵側僑儈儕儂俁儔儼倆儷儉債傾傯僂僨償儻儐儲儺兒兌兗黨蘭關興茲養獸囅內岡冊寫軍農塚馮衝決況凍淨淒涼淩減湊凜幾鳳鳧憑凱擊氹鑿芻劃劉則剛創刪別剗剄劊劌剴劑剮劍剝劇勸辦務勱動勵勁勞勢勳猛勩勻匭匱區醫華協單賣盧鹵臥衛卻巹廠廳曆厲壓厭厙廁廂厴廈廚廄廝縣參靉靆雙發變敘疊葉號歎嘰籲後嚇呂嗎唚噸聽啟吳嘸囈嘔嚦唄員咼嗆嗚詠哢嚨嚀噝吒噅鹹呱響啞噠嘵嗶噦嘩噲嚌噥喲嘜嗊嘮啢嗩唕喚呼嘖嗇囀齧囉嘽嘯噴嘍嚳囁嗬噯噓嚶囑嚕劈囂謔團園囪圍圇國圖圓聖壙場阪壞塊堅壇壢壩塢墳墜壟壟壚壘墾坰堊墊埡墶壋塏堖塒塤堝墊垵塹墮壪牆壯聲殼壺壼處備複夠頭誇夾奪奩奐奮獎奧妝婦媽嫵嫗媯姍薑婁婭嬈嬌孌娛媧嫻嫿嬰嬋嬸媼嬡嬪嬙嬤孫學孿寧寶實寵審憲宮寬賓寢對尋導壽將爾塵堯尷屍盡層屭屜屆屬屢屨嶼歲豈嶇崗峴嶴嵐島嶺嶽崠巋嶨嶧峽嶢嶠崢巒嶗崍嶮嶄嶸嶔崳嶁脊巔鞏巰幣帥師幃帳簾幟帶幀幫幬幘幗冪襆幹並廣莊慶廬廡庫應廟龐廢廎廩開異棄張彌弳彎彈強歸當錄彠彥徹徑徠禦憶懺憂愾懷態慫憮慪悵愴憐總懟懌戀懇惡慟懨愷惻惱惲悅愨懸慳憫驚懼慘懲憊愜慚憚慣湣慍憤憒願懾憖怵懣懶懍戇戔戲戧戰戩戶紮撲扡執擴捫掃揚擾撫拋摶摳掄搶護報擔擬攏揀擁攔擰撥擇掛摯攣掗撾撻挾撓擋撟掙擠揮撏撈損撿換搗據撚擄摑擲撣摻摜摣攬撳攙擱摟攪攜攝攄擺搖擯攤攖撐攆擷擼攛擻攢敵斂數齋斕鬥斬斷無舊時曠暘曇晝曨顯晉曬曉曄暈暉暫曖劄術樸機殺雜權條來楊榪傑極構樅樞棗櫪梘棖槍楓梟櫃檸檉梔柵標棧櫛櫳棟櫨櫟欄樹棲樣欒棬椏橈楨檔榿橋樺檜槳樁夢檮棶檢欞槨櫝槧欏橢樓欖櫬櫚櫸檟檻檳櫧橫檣櫻櫫櫥櫓櫞簷檁歡歟歐殲歿殤殘殞殮殫殯毆毀轂畢斃氈毿氌氣氫氬氳彙漢汙湯洶遝溝沒灃漚瀝淪滄渢溈滬濔濘淚澩瀧瀘濼瀉潑澤涇潔灑窪浹淺漿澆湞溮濁測澮濟瀏滻渾滸濃潯濜塗湧濤澇淶漣潿渦溳渙滌潤澗漲澀澱淵淥漬瀆漸澠漁瀋滲溫遊灣濕潰濺漵漊潷滾滯灩灄滿瀅濾濫灤濱灘澦濫瀠瀟瀲濰潛瀦瀾瀨瀕灝滅燈靈災燦煬爐燉煒熗點煉熾爍爛烴燭煙煩燒燁燴燙燼熱煥燜燾煆糊溜愛爺牘犛牽犧犢強狀獷獁猶狽麅獮獰獨狹獅獪猙獄猻獫獵獼玀豬貓蝟獻獺璣璵瑒瑪瑋環現瑲璽瑉玨琺瓏璫琿璡璉瑣瓊瑤璦璿瓔瓚甕甌電畫暢佘疇癤療瘧癘瘍鬁瘡瘋皰屙癰痙癢瘂癆瘓癇癡癉瘮瘞瘺癟癱癮癭癩癬癲臒皚皺皸盞鹽監蓋盜盤瞘眥矓著睜睞瞼瞞矚矯磯礬礦碭碼磚硨硯碸礪礱礫礎硜矽碩硤磽磑礄確鹼礙磧磣堿镟滾禮禕禰禎禱禍稟祿禪離禿稈種積稱穢穠穭稅穌穩穡窮竊竅窯竄窩窺竇窶豎競篤筍筆筧箋籠籩築篳篩簹箏籌簽簡籙簀篋籜籮簞簫簣簍籃籬籪籟糴類秈糶糲粵糞糧糝餱緊縶糸糾紆紅紂纖紇約級紈纊紀紉緯紜紘純紕紗綱納紝縱綸紛紙紋紡紵紖紐紓線紺絏紱練組紳細織終縐絆紼絀紹繹經紿綁絨結絝繞絰絎繪給絢絳絡絕絞統綆綃絹繡綌綏絛繼綈績緒綾緓續綺緋綽緔緄繩維綿綬繃綢綯綹綣綜綻綰綠綴緇緙緗緘緬纜緹緲緝縕繢緦綞緞緶線緱縋緩締縷編緡緣縉縛縟縝縫縗縞纏縭縊縑繽縹縵縲纓縮繆繅纈繚繕繒韁繾繰繯繳纘罌網羅罰罷羆羈羥羨翹翽翬耮耬聳恥聶聾職聹聯聵聰肅腸膚膁腎腫脹脅膽勝朧腖臚脛膠脈膾髒臍腦膿臠腳脫腡臉臘醃膕齶膩靦膃騰臏臢輿艤艦艙艫艱豔艸藝節羋薌蕪蘆蓯葦藶莧萇蒼苧蘇檾蘋莖蘢蔦塋煢繭荊薦薘莢蕘蓽蕎薈薺蕩榮葷滎犖熒蕁藎蓀蔭蕒葒葤藥蒞蓧萊蓮蒔萵薟獲蕕瑩鶯蓴蘀蘿螢營縈蕭薩蔥蕆蕢蔣蔞藍薊蘺蕷鎣驀薔蘞藺藹蘄蘊藪槁蘚虜慮虛蟲虯蟣雖蝦蠆蝕蟻螞蠶蠔蜆蠱蠣蟶蠻蟄蛺蟯螄蠐蛻蝸蠟蠅蟈蟬蠍螻蠑螿蟎蠨釁銜補襯袞襖嫋褘襪襲襏裝襠褌褳襝褲襇褸襤繈襴見觀覎規覓視覘覽覺覬覡覿覥覦覯覲覷觴觸觶讋譽謄訁計訂訃認譏訐訌討讓訕訖訓議訊記訒講諱謳詎訝訥許訛論訩訟諷設訪訣證詁訶評詛識詗詐訴診詆謅詞詘詔詖譯詒誆誄試詿詩詰詼誠誅詵話誕詬詮詭詢詣諍該詳詫諢詡譸誡誣語誚誤誥誘誨誑說誦誒請諸諏諾讀諑誹課諉諛誰諗調諂諒諄誶談誼謀諶諜謊諫諧謔謁謂諤諭諼讒諮諳諺諦謎諞諝謨讜謖謝謠謗諡謙謐謹謾謫譾謬譚譖譙讕譜譎讞譴譫讖穀豶貝貞負貟貢財責賢敗賬貨質販貪貧貶購貯貫貳賤賁貰貼貴貺貸貿費賀貽賊贄賈賄貲賃賂贓資賅贐賕賑賚賒賦賭齎贖賞賜贔賙賡賠賧賴賵贅賻賺賽賾贗讚贇贈贍贏贛赬趙趕趨趲躉躍蹌蹠躒踐躂蹺蹕躚躋踴躊蹤躓躑躡蹣躕躥躪躦軀車軋軌軒軑軔轉軛輪軟轟軲軻轤軸軹軼軤軫轢軺輕軾載輊轎輈輇輅較輒輔輛輦輩輝輥輞輬輟輜輳輻輯轀輸轡轅轄輾轆轍轔辭辯辮邊遼達遷過邁運還這進遠違連遲邇逕跡適選遜遞邐邏遺遙鄧鄺鄔郵鄒鄴鄰鬱郤郟鄶鄭鄆酈鄖鄲醞醱醬釅釃釀釋裏钜鑒鑾鏨釓釔針釘釗釙釕釷釺釧釤鈒釩釣鍆釹鍚釵鈃鈣鈈鈦鈍鈔鍾鈉鋇鋼鈑鈐鑰欽鈞鎢鉤鈧鈁鈥鈄鈕鈀鈺錢鉦鉗鈷缽鈳鉕鈽鈸鉞鑽鉬鉭鉀鈿鈾鐵鉑鈴鑠鉛鉚鈰鉉鉈鉍鈹鐸鉶銬銠鉺銪鋏鋣鐃銍鐺銅鋁銱銦鎧鍘銖銑鋌銩銛鏵銓鉿銚鉻銘錚銫鉸銥鏟銃鐋銨銀銣鑄鐒鋪鋙錸鋱鏈鏗銷鎖鋰鋥鋤鍋鋯鋨鏽銼鋝鋒鋅鋶鐦鐧銳銻鋃鋟鋦錒錆鍺錯錨錡錁錕錩錫錮鑼錘錐錦鍁錈錇錟錠鍵鋸錳錙鍥鍈鍇鏘鍶鍔鍤鍬鍾鍛鎪鍠鍰鎄鍍鎂鏤鎡鏌鎮鎛鎘鑷鐫鎳鎿鎦鎬鎊鎰鎔鏢鏜鏍鏰鏞鏡鏑鏃鏇鏐鐔钁鐐鏷鑥鐓鑭鐠鑹鏹鐙鑊鐳鐶鐲鐮鐿鑔鑣鑞鑲長門閂閃閆閈閉問闖閏闈閑閎間閔閌悶閘鬧閨聞闥閩閭闓閥閣閡閫鬮閱閬闍閾閹閶鬩閿閽閻閼闡闌闃闠闊闋闔闐闒闕闞闤隊陽陰陣階際陸隴陳陘陝隉隕險隨隱隸雋難雛讎靂霧霽黴靄靚靜靨韃鞽韉韝韋韌韍韓韙韞韜韻頁頂頃頇項順須頊頑顧頓頎頒頌頏預顱領頗頸頡頰頲頜潁熲頦頤頻頮頹頷頴穎顆題顒顎顓顏額顳顢顛顙顥纇顫顬顰顴風颺颭颮颯颶颸颼颻飀飄飆飆飛饗饜飣饑飥餳飩餼飪飫飭飯飲餞飾飽飼飿飴餌饒餉餄餎餃餏餅餑餖餓餘餒餕餜餛餡館餷饋餶餿饞饁饃餺餾饈饉饅饊饌饢馬馭馱馴馳驅馹駁驢駔駛駟駙駒騶駐駝駑駕驛駘驍罵駰驕驊駱駭駢驫驪騁驗騂駸駿騏騎騍騅騌驌驂騙騭騤騷騖驁騮騫騸驃騾驄驏驟驥驦驤髏髖髕鬢魘魎魚魛魢魷魨魯魴魺鮁鮃鯰鱸鮋鮓鮒鮊鮑鱟鮍鮐鮭鮚鮳鮪鮞鮦鰂鮜鱠鱭鮫鮮鮺鯗鱘鯁鱺鰱鰹鯉鰣鰷鯀鯊鯇鮶鯽鯒鯖鯪鯕鯫鯡鯤鯧鯝鯢鯰鯛鯨鯵鯴鯔鱝鰈鰏鱨鯷鰮鰃鰓鱷鰍鰒鰉鰁鱂鯿鰠鼇鰭鰨鰥鰩鰟鰜鰳鰾鱈鱉鰻鰵鱅鰼鱖鱔鱗鱒鱯鱤鱧鱣鳥鳩雞鳶鳴鳲鷗鴉鶬鴇鴆鴣鶇鸕鴨鴞鴦鴒鴟鴝鴛鴬鴕鷥鷙鴯鴰鵂鴴鵃鴿鸞鴻鵐鵓鸝鵑鵠鵝鵒鷳鵜鵡鵲鶓鵪鶤鵯鵬鵮鶉鶊鵷鷫鶘鶡鶚鶻鶿鶥鶩鷊鷂鶲鶹鶺鷁鶼鶴鷖鸚鷓鷚鷯鷦鷲鷸鷺鸇鷹鸌鸏鸛鸘鹺麥麩黃黌黶黷黲黽黿鼂鼉鞀鼴齇齊齏齒齔齕齗齟齡齙齠齜齦齬齪齲齷龍龔龕龜誌製谘隻裡係範鬆冇嚐嘗鬨麵準鐘彆閒乾儘臟拚' } function Traditionalized(cc) { var str = ''; var ss = JTPYStr(); var tt = FTPYStr(); for (var i = 0; i < cc.length; i++) { if (cc.charCodeAt(i) > 10000 && ss.indexOf(cc.charAt(i)) != -1) str += tt.charAt(ss.indexOf(cc.charAt(i))); else str += cc.charAt(i) } return str } function Simplized(cc) { var str = ''; var ss = JTPYStr(); var tt = FTPYStr(); for (var i = 0; i < cc.length; i++) { if (cc.charCodeAt(i) > 10000 && tt.indexOf(cc.charAt(i)) != -1) str += ss.charAt(tt.indexOf(cc.charAt(i))); else str += cc.charAt(i) } return str } function setCookie(name, value, days) { if (days) { var date = new Date(); date.setTime(date.getTime() + (days * 24 * 60 * 60 * 1000)); var expires = \"; expires=\" + date.toGMTString() } else var expires = \"\"; document.cookie = name + \"=\" + value + expires + \"; path=/\" } function getCookie(name) { var nameEQ = name + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i < ca.length; i++) { var c = ca[i]; while (c.charAt(0) == ' ') c = c.substring(1, c.length); if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length) } return null } function translateInitilization() { translateButtonObject = document.getElementById(translateButtonId); if (translateButtonObject) { with(translateButtonObject) { if (typeof(document.all) != \"object\") { href = \"javascript:translatePage();\" } else { href = \"#\"; onclick = new Function(\"translatePage(); return false;\") } } if (currentEncoding != targetEncoding) { setTimeout(\"translateBody()\", translateDelay); if (targetEncoding == 1) translateButtonObject.innerHTML = msgToSimplifiedChinese; else translateButtonObject.innerHTML = msgToTraditionalChinese } } }","link":"/js/tw_cn.js"}],"posts":[{"title":"Git、Nvm采用命令归档","text":"最近想做个人的博客，迫于经济压力选择了GithubPages+Hexo的方式建立，于是就把要用到的Git、Nvm命令记录下来。 Git常用命令12345678910111213141516171819202122232425262728293031323334353637383940414243git clone -b &quot;branch name&quot; repogit checkout -- readme.txt #把readme.txt文件在工作区的修改全部撤销git reset HEAD readme.txt #把readme.txt在暂存区的修改全部撤销git reset -- hard Head^ #把版本回推到上一个版本git reflog # 查看所有命令的版本git reset --hard ******** # 回滚到之前某一commitgit rm readme.txt # 从版本库中删除掉readme.txt一个文件git checkout -b 分支名 # 创建一个新的分支 并 切换过去也可以使用 git switch -c 分支名#相当于这两条命令git branch 分支名git checkout 分支名 # git switch 分支名git branch -d 分支名 #删除某一个分支git merge 分支名 # 将分支merge到master分支git log --graph # 分支合并图git merge --no-ff -m &quot;******&quot; 分支名 #不删除分支信息的情况下合并分支git stash # 暂时隐藏工作区的修改git stash apply #恢复现场，但是stash内容并不删除git stash pop #恢复的同时把stash内容也删除git stash list #查看工作区的所有修改内容git branch -D 分支名 强制性删除该分支git remote #查看远程仓库的名称 一般为ori#gingit push origin master # 提交到origin仓库里面的master分支git checkout -b dev origin/dev # 创建远程的origin的dev分支到本地。 Nvm常用命令1234567891011121314151617nvm install stable ## 安装最新稳定版 node，当前是node v10.15.0 (npm v6.4.1)nvm install &lt;version&gt; ## 安装指定版本，可模糊安装，如：安装v4.4.0，既可nvm install v4.4.0，又可nvm install 4.4nvm uninstall &lt;version&gt; ## 删除已安装的指定版本，语法与install类似nvm use &lt;version&gt; ## 切换使用指定的版本nodenvm ls ## 列出所有安装的版本nvm ls-remote ## 列出所有远程服务器的版本（官方node version list）nvm --version 显示当前安装的nvm版本nvm alias &lt;name&gt; &lt;version&gt; ## 给不同的版本号添加别名nvm unalias &lt;name&gt; ## 删除已定义的别名 1nvm list","link":"/2020/09/24/Git%E3%80%81Nvm%E9%87%87%E7%94%A8%E5%91%BD%E4%BB%A4%E5%BD%92%E6%A1%A3/"},{"title":"JavaScript中理解不到位的东东","text":"记录学习JavaScript中遇到难啃的骨头🦴… 高阶函数 map/reduce filter sort Array 闭包 RegExp正则表达式 JSON 面向对象编程 创建对象 原型继承简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。每个new出来的实例中包含一个_proto_指针，指向构造函数的原型。1_proto_ 指向 Person.prototype 原型对象(prototype)属性 1234567891011121314151617function Person(){}Person.prototype.name = &quot;Stone&quot;;Person.prototype.age = 28;Person.prototype.job = &quot;Software Engineer&quot;;Person.prototype.sayName = function(){ console.log(this.name);};var person1 = new Person();person1.sayName(); // &quot;Stone&quot;var person2 = new Person();person2.sayName(); // &quot;Stone&quot;console.log(person1.sayName == person2.sayName); // true 在默认情况下，所有原型对象都会自动获得一个 constructor（构造函数）属性，这个属性包含一个指向 prototype 属性所在函数的指针。就拿前面的例子来说，Person.prototype.constructor 指向 Person。而通过这个构造函数，我们还可继续为原型对象添加其他属性和方法。 1234567891011121314151617181920212223//用的最广泛function Person(name, age, job){ this.name = name; this.age = age; this.job = job; this.friends = [&quot;ZhangSan&quot;, &quot;LiSi&quot;];}Person.prototype = { constructor : Person, sayName : function(){ console.log(this.name); }}var person1 = new Person(&quot;Stone&quot;, 28, &quot;Software Engineer&quot;);var person2 = new Person(&quot;Sophie&quot;, 29, &quot;English Teacher&quot;);person1.friends.push(&quot;WangWu&quot;);console.log(person1.friends); // &quot;ZhangSan,LiSi,WangWu&quot;console.log(person2.friends); // &quot;ZhangSan,LiSi&quot;console.log(person1.friends === person2.friends); // falseconsole.log(person1.sayName === person2.sayName); // true 在这个例子中，实例属性都是在构造函数中定义的，而由所有实例共享的属性 constructor 和方法 sayName() 则是在原型中定义的。而修改了person1.friends（向其中添加一个新字符串），并不会影响到 person2.friends，因为它们分别引用了不同的数组。这种构造函数与原型混成的模式，是目前在 JavaScript 中使用最广泛、认同度最高的一种创建自定义类型的方法。可以说，这是用来定义引用类型的一种默认模式。 class继承","link":"/2020/09/25/JavaScript%E4%B8%AD%E7%90%86%E8%A7%A3%E4%B8%8D%E5%88%B0%E4%BD%8D%E7%9A%84%E4%B8%9C%E4%B8%9C/"},{"title":"JavaScript的拷贝","text":"JavaScript的拷贝的总结…… JavaScript的深浅拷贝 Javascript有六种基本数据类型（也就是简单数据类型），它们分别是：Undefined，Null，Boolean，Symbol，Number和String。还含有一种复杂数据类型，就是对象 注意Undefined和Null的区别，Undefined类型只有一个值，就是undefined，Null类型也只有一个值，也就是nullUndefined其实就是已声明未赋值的变量输出的结果null其实就是一个不存在的对象的结果 1234var c;console.log(c)//undefinedconsole.log(document.getElementById('wsscat'))//没有id为wsscat的节点,输出null 简单数据类型当一个变量指向另一个变量的时候就是创建一个副本，不能给基本数据类型的值添加属性 复杂数据类型当一个变量指向另一个变量就是创建一个指针副本，指向同一个对象而已 浅拷贝就是正常的 对象指向另一个对象，实际上复制指向指针，指向了同一个对象，一改动两个中的其中一个变量，对象都会变123456789var obj = { name:'wsscat', age:0}var obj2 = obj;obj2['c'] = 5;console.log(obj);//Object {name: &quot;wsscat&quot;, age: 0, c: 5}console.log(obj2);////Object {name: &quot;wsscat&quot;, age: 0, c: 5} 深拷贝就是备份，创建了新的对象。两个对象不会互相影响 数组的深拷贝对于数组使用slice（）和concat（）方法 slice（）返回一个新的数组 并没有修改当前的数组 12345678910var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];arr.slice(0, 3); // 从索引0开始，到索引3结束，但不包括索引3: ['A', 'B', 'C']arr.slice(3); // 从索引3开始到结束: ['D', 'E', 'F', 'G']//如果不给slice()传递任何参数，它就会从头到尾截取所有元素。利用这一点，我们可以很容易地复制一个Array：var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];var aCopy = arr.slice();aCopy; // ['A', 'B', 'C', 'D', 'E', 'F', 'G']aCopy === arr; // false concat（） 把当前的数组和另一数组连接起来，返回一个新的数组 并没有修改当前的数组 1234var arr = ['A', 'B', 'C'];var added = arr.concat([1, 2, 3]);added; // ['A', 'B', 'C', 1, 2, 3]arr; // ['A', 'B', 'C'] slice 12345var arr = ['wsscat', 'autumns', 'winds'];var arrCopy = arr.slice(0);arrCopy[0] = 'tacssw'console.log(arr)//['wsscat', 'autumns', 'winds']console.log(arrCopy)//['tacssw', 'autumns', 'winds'] concat 12345var arr = ['wsscat', 'autumns', 'winds'];var arrCopy = arr.concat();arrCopy[0] = 'tacssw'console.log(arr)//['wsscat', 'autumns', 'winds']console.log(arrCopy)//['tacssw', 'autumns', 'winds'] 对象的深拷贝对象我们可以定义一个新的对象并遍历新的属性上去实现深拷贝123456789101112var obj = { name:'wsscat', age:0}var obj2 = new Object();obj2.name = obj.name;obj2.age = obj.ageobj.name = 'autumns';console.log(obj);//Object {name: &quot;autumns&quot;, age: 0}console.log(obj2);//Object {name: &quot;wsscat&quot;, age: 0} 封装一个方法处理对象的深拷贝 (暂时没有看)12345678910111213141516171819var obj = { name: 'wsscat', age: 0}var deepCopy = function(source) { var result = {}; for(var key in source) { if(typeof source[key] === 'object') { result[key] = deepCopy(source[key]) } else { result[key] = source[key] } } return result;}var obj3 = deepCopy(obj)obj.name = 'autumns';console.log(obj);//Object {name: &quot;autumns&quot;, age: 0}console.log(obj3);//Object {name: &quot;wsscat&quot;, age: 0}","link":"/2021/01/13/JavaScript%E7%9A%84%E6%8B%B7%E8%B4%9D/"},{"title":"MarkDown语法","text":"MarkDown语法 加粗倾斜加粗并且倾斜 一级标题二级标题以此类推到6级（正文） 1代码块 代码块通过两行 ``` 符号框出，如果你写的代码是某种语言，那么可以在第一行末尾加上这个语言的名字，代码块内的代码就会执行对应的高亮语法，例如python行内代码有序列表：输入数字+.+空格 123 456 789无序列表：输入- + 空格 123 456 789 区块引用","link":"/2020/10/13/MarkDown%E8%AF%AD%E6%B3%95/"},{"title":"代码面试需要知道的8种数据结构","text":"什么是数据结构？数据结构是计算机存储、组织数据的方式。对于特定的数据结构(比如数组)，有些操作效率很高(读某个数组元素)，有些操作的效率很低(删除某个数组元素)。程序员的目标是为当前的问题选择最优的数据结构。 为什么我们需要数据结构？数据是程序的核心要素，因此数据结构的价值不言而喻。无论你在写什么程序，你都需要与数据打交道，比如员工工资、股票价格、杂货清单或者电话本。在不同场景下，数据需要以特定的方式存储，我们有不同的数据结构可以满足我们的需求。 8 种常用数据结构 数组 栈 队列 链表 图 树 前缀树 哈希表 1. 数组数组(Array)大概是最简单，也是最常用的数据结构了。其他数据结构，比如栈和队列都是由数组衍生出来的。下图展示了 1 个数组，它有 4 个元素： 每一个数组元素的位置由数字编号，称为下标或者索引(index)。大多数编程语言的数组第一个元素的下标是 0。根据维度区分，有 2 种不同的数组： 一维数组(如上图所示) 多维数组(数组的元素为数组) 2. 栈撤回，即 Ctrl+Z，是我们最常见的操作之一，大多数应用都会支持这个功能。你知道它是怎么实现的吗？答案是这样的：把之前的应用状态(限制个数)保存到内存中，最近的状态放到第一个。这时，我们需要栈(stack)来实现这个功能。栈中的元素采用 LIFO (Last In First Out)，即后进先出。 栈的基本操作 Push — 在栈的最上方插入元素 Pop — 返回栈最上方的元素，并将其删除 isEmpty — 查询栈是否为空 Top — 返回栈最上方的元素，并不删除 3. 队列队列(Queue)与栈类似，都是采用线性结构存储数据。它们的区别在于，栈采用 LIFO 方式，而队列采用先进先出，即FIFO(First in First Out)。 队列的基本操作 Enqueue — 在队列末尾插入元素 Dequeue — 将队列第一个元素删除 isEmpty — 查询队列是否为空 Top — 返回队列的第一个元素 4. 链表链表(Linked List)也是线性结构，它与数组看起来非常像，但是它们的内存分配方式、内部结构和插入删除操作方式都不一样。链表是一系列节点组成的链，每一个节点保存了数据以及指向下一个节点的指针。链表头指针指向第一个节点，如果链表为空，则头指针为空或者为 null。链表可以用来实现文件系统、哈希表和邻接表。 链表分为 2 种： 单向链表 双向链表 *链表的基本操作** InsertAtEnd — 在链表结尾插入元素 InsertAtHead — 在链表开头插入元素 Delete — 删除链表的指定元素 DeleteAtHead — 删除链表第一个元素 Search — 在链表中查询指定元素 isEmpty — 查询链表是否为空 5. 图图(graph)由多个节点(vertex)构成，节点之间阔以互相连接组成一个网络。(x, y)表示一条边(edge)，它表示节点 x 与 y 相连。边可能会有权值(weight/cost)。 图分为两种: 无向图 有向图 在编程语言中，图有可能有以下两种形式表示： 邻接矩阵(Adjacency Matrix) 邻接表(Adjacency List) 遍历图有两种算法 广度优先搜索(Breadth First Search) 深度优先搜索(Depth First Search) 6. 树树(Tree)是一个分层的数据结构，由节点和连接节点的边组成。树是一种特殊的图，它与图最大的区别是没有循环。 树被广泛应用在人工智能和一些复杂算法中，用来提供高效的存储结构。 树有很多分类： N 叉树(N-ary Tree) 平衡树(Balanced Tree) 二叉树(Binary Tree) 二叉查找树(Binary Search Tree) 平衡二叉树(AVL Tree) 红黑树(Red Black Tree) 2-3 树(2–3 Tree)其中，二叉树和二叉查找树是最常用的树。 7. 前缀树前缀树(Prefix Trees 或者 Trie)与树类似，用于处理字符串相关的问题时非常高效。它可以实现快速检索，常用于字典中的单词查询，搜索引擎的自动补全甚至 IP 路由。 单词是按照字母从上往下存储，“p”, “s”和“r”节点分别表示“top”, “thus”和“their”的单词结尾。 8. 哈希表哈希(Hash)将某个对象变换为唯一标识符，该标识符通常用一个短的随机字母和数字组成的字符串来代表。哈希可以用来实现各种数据结构，其中最常用的就是哈希表(hash table)。 哈希表通常由数组实现。 哈希表的性能取决于 3 个指标： 哈希函数 哈希表的大小 哈希冲突处理方式下图展示了有数组实现的哈希表，数组的下标即为哈希值，由哈希函数计算，作为哈希表的键(key)，而数组中保存的数据即为值(value)。","link":"/2020/09/24/%E4%BB%A3%E7%A0%81%E9%9D%A2%E8%AF%95%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%848%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-1/"},{"title":"前端知识点总结-BOM","text":"前端知识点总结——BOM好记性不如烂笔头！ 1.BOM: Browser Object Model什么是: 专门操作浏览器窗口的API没有标准, 导致浏览器兼容性问题包括:windowhistorylocationnavigatordomeventscreen 2.window:属性: .innerWidth, .innerHeight 浏览器窗口中，文档显示区的宽和高方法: .open() .close() .open(“url”,”name”) 三种: 123451.在当前窗口打开，可后退: .open(&quot;url&quot;,&quot;_self&quot;)2.在新窗口打开，可打开多个: .open(&quot;url&quot;,&quot;_blank&quot;)3.在新窗口打开，只能打开一个: .open(&quot;url&quot;,&quot;自定义窗口名&quot;) 3.history: 保存当前窗口打开后，成功访问过的url的历史记录栈在当前窗口中，每访问一个新url，都会将新url压入historyAPI: history.go(n) 3种: 1234前进: history.go(1) 后退: history.go(-1) 刷新: history.go(0) 4.location: 保存当前窗口正在打开的url的对象属性:.href 完整url地址.protocol 协议.host 主机名+端口号.hostname 主机名.port 端口号.pathname 相对路径.hash #锚点地址.search ?查询字符串 方法: 在当前窗口打开，可后退: location.assign(url) =&gt; location.href=url =&gt; location=url 在当前窗口打开，禁止后退: location.replace(url) 重新加载页面: 刷新: 2种: 普通刷新: 优先从浏览器本地缓冲获取资源: F5 history.go(0) location.reload(/false/) 强制刷新: 无论本地是否有缓存，总是强制从服务器获取资源 location.reload(true) 5.定时器: 2种: 周期性定时器: 什么是: 让程序每隔指定的时间间隔，反复执行一项任务 何时: 只要让程序按照指定的时间间隔，自动执行一项任务 如何: 3件事: 1.任务函数: 让定时器反复执行的任务 2.启动定时器: timer=setInterval(task, interval) 1让程序，每隔interval 毫秒自动执行一次task任务 3.停止定时器: clearInterval(timer) 12345timer: 定时器的序号, 在内存中唯一标识定时器的整数 专门用于停止定时器 如何获得: 只能在启动定时器时获得。 何时: 只要一个定时器可能被停止，就要在启动时，先保存定时器序号 好的习惯: 在clearInterval之后，手动清除timer中残留的序号: timer=null; 停止定时器: 2种情况: 用户手动停止: 定时器可自动停止: 在任务函数中，设定临界值，如果没有达到临界值，则继续执行任务，否则，如果达到临界值，就自动调用clearInterval 2.一次性定时器:什么是: 让程序先等待一段时间，再执行一次任务。执行后，自动停止。何时: 只要让程序延迟执行一件事时如何: 3件事:1.task2.启动定时器: timer=setTimeout(task,wait) 1让程序等待wait毫秒后，自动执行一次task，执行后自动停止 3.停止定时器: clearTimeout(timer) 6.定时器原理:定时器中的任务函数，必须等待主程序所有语句执行后，才能执行。 7.navigator:1.什么是: 保存浏览器配置信息的对象包括:.cookieEnabled: 判断当前浏览器是否启用cookie 2.什么是cookie: 在客户端持久存储用户私密数据的小文件为什么: 内存中所有数据都是临时的! 程序关闭，内存中一切变量都释放!何时: 只要希望在客户端持久保存数据，都用cookie.plugins: 包含浏览器所有插件信息的集合 3.什么是插件: 为浏览器添加新功能的小软件 1如何判断是否安装指定插件: .userAgent: 保存浏览器名称和版本号的字符串何时: 只要判断浏览器名称和版本号 8.event:什么是事件: 人为触发的，或浏览器自动触发的页面内容状态的改变。什么是事件处理函数: 当事件发生时，自动执行的函数。如何绑定: 3种: 在HTML中绑定: 绑定: 当事件发生时: 自动执行js语句 问题: 不符合内容与行为分离的原则，不便于维护和重用 但是: 在组件开发中，反而要求内容，行为和样式集中定义在一个小组件内，自成体系。 在js中绑定, 每个事件只能绑定一个处理函数: ANY.on事件名=function(){ … } 当事件发生时: ANY.on事件名() //this-&gt;ANY 问题: 用赋值方式绑定事件处理函数 在js中绑定，每个事件可绑定多个处理函数: ANY.addEventListener(‘事件名’,handler) 在浏览器中为ANY元素的指定事件，添加一个事件监听对象。将事件监听对象加入到浏览器的监听队列中。 触发事件时: 浏览器会遍历监听队列中的每个监听对象，找到触发事件元素上对应事件的监听对象，调用其处理函数 移除事件监听: ANY.removeEventListener(‘事件名’,handler) 说明: handler必须是绑定时使用的原函数对象 强调: 如果一个处理函数，有可能被移除，则不能使用匿名函数绑定。应使用有名的函数绑定 9.DOM事件模型:什么是: 从事件触发到处理函数执行，所经过的过程3个阶段: 捕获capture: 由外向内，记录各级父元素上绑定的事件处理函数。——仅记录，不触发! 目标触发: 优先触发实际点击的元素上绑定的处理函数 冒泡执行: 由内向外，按捕获阶段记录的处理函数的倒序，依次执行父元素上的处理函数。 10.事件对象:什么是: 当事件发生时，自动创建的，封装事件信息的对象何时: 只要希望获得事件信息，或修改事件的默认行为时如何获取: 事件对象默认总是以处理函数第一个参数，自动传入如何使用: 取消冒泡: e.stopPropagation() 利用冒泡: 优化: 尽量减少事件监听的个数 为什么: 浏览器查找事件监听，采用的是遍历的方式 1事件监听多，浏览器查找就慢 何时: 如果对多个子元素绑定相同事件时，都要利用冒泡 如何: 只要在父元素绑定一次，所有子元素共用即可! 2个难题: 12345671. 获得目标元素: 目标元素: 最初实际触发事件的当前元素 如何获得: 错误: this-&gt;父元素 正确: e.target2. 筛选目标元素: 比如: 通过nodeName, class, 内容。。。 阻止默认行为: 何时: 只要事件的默认行为不是想要的 如何: e.preventDefault(); 何时: 用a当按钮时，a会自动向地址栏中添加#锚点地址。 提交表单时，如果验证没通过，可阻止提交 自定义表单提交: input button + onclick + form.submit input submit + form.onsubmit事件 + e.preventDefault() HTML5中拖拽API: 首先要阻止浏览器默认的拖拽行为 11.鼠标坐标: 3组:12341\\. 相对于屏幕左上角: e.screenX, e.screenY2\\. 相对于文档显示区左上角: e.clientX, e.clientY3\\. 相对于当前元素左上角: e.offsetX, e.offsetY 12.页面滚动:事件: window.onscroll获得页面滚动过的高度: body顶部超出文档显示区顶部的距离 12scrollTop=document.documentElement.scrollTop ||document.body.scrollTop; 滚动API:window.scrollTo(left, top)window.scrollBy(left的增量,top的增量)","link":"/2020/09/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-BOM/"},{"title":"入坑小程序","text":"热爱技术、尊重技术。要学会寻找自己喜欢的，然后去学习利用它，完善自己的技能。等这段时间过去了，找到工作了，时间空下来时好好“入坑”。","link":"/2020/09/26/%E5%85%A5%E5%9D%91%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"title":"闭包","text":"JS闭包的理解 个人理解：函数中嵌套函数。 闭包的定义及其优缺点闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。 闭包的缺点是常驻内存，会增大内存的使用量，使用不当会造成内存泄漏。 应用闭包主要是为了：设计私有变量和方法。 一般来讲，函数执行完毕后，局部活动对象就会被销毁，内存中仅保存全局作用域，但是闭包的情况有所不同！ 理解闭包的前提是理解另外两个内容：作用域链、垃圾回收 作用域链原理 作用域链：当代码在执行过程中，会创建变量对象的一个作用域链。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。 123456789101112131415//全局环境中有一个变量color和一个函数changeColor()var color = &quot;blue&quot;; //changeColor()的局部环境中有一个anotherColor变量和swapColors()函数 function changeColor() { var anotherColor = &quot;red&quot;; //swapColors()环境中只有一个tempColor function swapColors() { var tempColor = anotherColor; anotherColor = color; color = tempColor; } swapColors(); } changeColor(); 全局环境只能访问到变量color changeColor()局部环境也可以访问color swapColors()可以访问其他两个环境的所有变量，但是那两个变量都无权访问tempColor 总结：内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。每个环境都可以向上搜索作用域链，但任何环境都不能向下搜索作用域链而进入另一个执行环境。 垃圾回收原理 javascript中如果一个对象不再被引用，那么这个对象就会被回收。 如果两个对象互相引用，而不再被第3者引用，那么这两个互相引用的对象也会被回收。 嵌套函数的闭包 12345678910var f =function(){ var a=9999; function f1(){ console.log(a); } f1();};f();//输出：9999 函数嵌套时候，在f执行完成之后，变量a还要被f1这个内部嵌套的函数继续使用，因此a不会被释放。js解析器发现函数中嵌套了函数时，就会把函数中的变量和子函数的变量一起保存，构成了一个“闭包”。这些变量不会被内存回收器回收，只有当内部嵌套的函数不在执行后，才会被回收。 ###闭包的特性和使用闭包的好处闭包有三个特性： 函数嵌套函数 函数内部可以引用外部的参数和变量 参数和变量不会被垃圾回收机制回收 使用闭包的好处： 希望一个变量长期驻扎内存 避免全局变量污染 私有成员变量的存在 闭包案例属性 12345678910var person = function(){ var name = &quot;zjw&quot;; this.getName = function(){ return name; };};var p = new person();console.log(p.getName());//输出：zjw //name属性通过getName方法的取到。 变量的累加全局变量的累加 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var i = 1; function text() { i++; alert(i); } text();//2 text();//3 &lt;/script&gt; 局部变量的累加 123456789&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function text() { var i = 1; i++; alert(i); } text();//2 text();//2 &lt;/script&gt; 上面的代码没有实现累加功能，改写代码如下： 12345678910111213&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; function text() { var i = 1; return function () {//函数嵌套 i++; alert(i); } } var a = text();//外部函数赋给a a();//2 第一次调用函数text() i=2 调用一次text()函数，其实调用的是里面内部函数的返回值 a();//3 第二次调用函数text() i=3 以此类推-累加 //模块化代码，减少全局变量的污染 &lt;/script&gt; ###闭包中this的问题在闭包中使用this对象可能导致一些问题 1234567891011121314151617&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var name = &quot;The Window&quot;; var object = { name: &quot;My Object&quot;, getNameFunc: function () { return function () { return this.name; }; } }; alert(object.getNameFunc()());//The Window &lt;/script&gt; 代码先创建了一个全局变量name，又创建了一个包含name属性的对象。这个对象还包含一个getNameFunc()方法，返回一个匿名函数，匿名函数又返回一个this.name。调用object.getNameFunc()()返回一个字符串。内部函数搜索的时候只搜索到活动对象。修改代码如下： 12345678910111213141516171819//在定义匿名函数前，把this对象赋值给that变量，闭包也可以访问这个变量。即使函数返回，仍然引用着object&lt;script type=&quot;text/javascript&quot; charset=&quot;UTF-8&quot;&gt; var name = &quot;The Window&quot;; var object = { name: &quot;My Object&quot;, getNameFunc: function () { var that = this; return function () { return that.name; }; } }; alert(object.getNameFunc()());//My Object &lt;/script&gt; 学习了闭包也不知道到底哪里用到，到底有什么用。回答：(其实你写的每一个js函数都是闭包，一个js函数的顶层作用域就是window对象，js的执行环境本身就是一个scope（浏览器的window/node的global），我们通常称之为全局作用域。每个函数，不论多深，都可以认为是全局scope的子作用域，可以理解为闭包。)","link":"/2020/10/13/%E9%97%AD%E5%8C%85/"},{"title":"数据结构JavaScript实现","text":"##数据结构最近在看《数据结构与算法的JavaScript的描述》一书。对看过的知识进行总结和实现。 栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111 function Stack(){ this.dataScore = []; this.top = 0; this.push = push; this.pop = pop; this.peek = peek; this.clear = clear; this.length = length; }function push(element){ this.dataScore[this.top++] = element;}function peek(){ return this.dataScore[this.top-1];}function pop(){ return this.dataScore[--this.top];}function clear(){ this.top = 0;}function length(){ return this.top;}var s = new Stack();s.push('1');s.push('2');s.push('3');console.log(s.length())s.clear()console.log(s.peek())//1.数制间的相互转换 适用于2到9进制function mulBase(num,base){ var s = new Stack(); do{ s.push(num%base); num = Math.floor(num = num/base); }while (num&gt;0) var converted = &quot;&quot;; while(s.length()&gt;0){ converted +=s.pop(); } return converted;}console.log(mulBase(32,2)); //2.判断回文数function isHW(word){ var s = new Stack(); for(var i = 0;i&lt;word.length;++i){ s.push(word[i]); }var rWord = &quot;&quot;;while(s.length()&gt;0){ rWord += s.pop();}if(word ==rWord){ console.log(word + &quot;是回文数&quot;);}else{ return false;}}console.log(isHW(&quot;racecar&quot;));//3.模拟递归function fact(n){ var s = new Stack(); while(n&gt;1){ s.push(n--); } var product = 1; while (s.length()&gt;0){ product *= s.pop(); } return product;}console.log(fact(5));//算术表达式的括号是否匹配function check(str){ var s = new Stack(); for(let i =0;i&lt;str.length-1;i++){ if(str[i] === '('){ s.push('('); }else if(str[i] === ')'){ if(s.length()&gt;0){ s.pop(); }else{ console.log(&quot;缺少左括号&quot;); return false; } } }//return (s.length()&lt;=0 ? true : false); if(s.length()&lt;=0){ console.log(&quot;不缺少&quot;); } else{ console.log(&quot;缺少右括号&quot;); }}console.log(check(&quot;23+3.14159)*24&quot;)); 队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990function Queue(){ this.dataScore = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.back = back; this.toString = toString; this.empty = empty;}function enqueue(element){ this.dataScore.push(element);}function dequeue(){ return this.dataScore.shift();}function front(){ //队首 return this.dataScore[0];}function back(){ return this.dataScore[this.dataScore.length - 1];}function toString(){ var retStr = &quot;&quot;; for(var i =0;i&lt;this.dataScore.length;i++){ retStr += this.dataScore[i] + &quot;\\n&quot;; } return retStr;}function empty(){ if(this.dataScore.length == 0 ){ return true; }else{ return false; }}//test data// var q =new Queue();// q.enqueue('1');// q.enqueue('2');// q.enqueue('3');// q.enqueue('4');// console.log(q.toString());// console.log(q.front());// console.log(q.back());//基数排序var queues =[];for(var i=0;i&lt;10;i++){ queues[i] = new Queue();}var nums = [];for(var i =0;i&lt;10;i++){ nums[i] = Math.floor(Math.floor(Math.random()*101)); //console.log(nums[i]);}function distribute(nums,queues,n,digit){ for(var i=0;i&lt;n;i++){ if(digit ==1 ){ queues[nums[i]%10].enqueue(nums[i]); //个位数 个位数进不同的数组 }else{ queues[Math.floor(nums[i]/10)].enqueue(nums[i]); //十位数 然后再排10位数的 } }}function collect(queues,nums){ var i =0; for(var digit = 0;digit&lt;10;digit++){ while(!queues[digit].empty()){ nums[i++] = queues[digit].dequeue(); } }}function dispArray(arr){ for(var i=0;i&lt;arr.length;i++){ console.log(arr[i] + &quot;&quot;); }}dispArray(nums);console.log('++++++++++++++++++++++++++++++++++');distribute(nums,queues,10,1);collect(queues,nums);dispArray(queues,nums);distribute(nums,queues,10,10)collect(queues,nums);dispArray(nums); 队列之优先队列 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//优先级高的先 相同的优先级就按照顺序来function Queue(){ this.dataScore = []; this.enqueue = enqueue; this.dequeue = dequeue; this.front = front; this.back = back; this.toString = toString; this.empty = empty; }function Patient(name,code){ this.name = name; this.code = code;}function enqueue(element){ this.dataScore.push(element);}function dequeue(){ // return this.dataScore.shift(); var priority = this.dataScore[0].code; for(var i=1;i&lt;this.dataScore.length;i++){ if(this.dataScore[i].code&lt;priority) priority = i; } return this.dataScore.splice(priority,1);}function front(){ //队首 return this.dataScore[0];}function back(){ return this.dataScore[this.dataScore.length - 1];}function toString(){ var retStr = &quot;&quot;; for(var i =0;i&lt;this.dataScore.length;i++){ // retStr += this.dataScore[i] + &quot;\\n&quot;; retStr += this.dataScore[i].name + &quot; code：&quot; + this.dataScore[i].code + &quot;\\n&quot;; } return retStr;}function empty(){ if(this.dataScore.length == 0 ){ return true; }else{ return false; }}var p = new Patient('zjw',5);var ed = new Queue();ed.enqueue(p);p = new Patient('lx',4);ed.enqueue(p);p = new Patient('jw',6);ed.enqueue(p);p = new Patient('jh',1);ed.enqueue(p);p = new Patient('zzz',1);ed.enqueue(p);console.log(ed.toString());// console.log(ed.dequeue());// console.log(ed.toString());// console.log(ed.dequeue());// console.log(ed.toString());// console.log(ed.dequeue());// console.log(ed.toString());var seen = ed.dequeue();console.log(seen);console.log(ed.toString());var seen = ed.dequeue();console.log(seen);console.log(ed.toString());var seen = ed.dequeue();console.log(seen);console.log(ed.toString()); 链表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556function Node(element){ this.element = element; this.next =null;}function LList(){ this.head = new Node('head'); this.find = find; this.insert= insert; this.findPrevious = findPrevious; this.remove = remove; this.display = display;}function find(item){ var currNode = this.head; if (currNode.element!=item){ currNode = currNode.next; } return currNode;}function insert(newElement,item){ //后面插入 var newNode = new Node(newElement); var current = this.find(item); newNode.next = current.next; current.next = newNode;}function display(){ var currNode = this.head; while(!(currNode.next==null)){ console.log(currNode.next.element);//不显示头结点嘛 currNode = currNode.next; }}function findPrevious(item){ var currNode = this.head; if(!(currNode.next == null) &amp;&amp; (currNode.next.element !=item)){ currNode = currNode.next; } return currNode;}function remove(item){ var prevNode = this.findPrevious(item); if(!(prevNode.next == null)){ prevNode.next = prevNode.next.next; }}var cities = new LList();cities.insert('Conway','head');cities.insert('Russellvulle','Conway');cities.insert('Caelisle','Russellvulle');cities.insert('Alma','Caelisle'); //================cities.display();console.log(&quot;+++++++++++++++++++++++&quot;)cities.remove('Caelisle');cities.display(); 散列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657function HashTable(){ this.table = new Array(137); this.simpleHash = simpleHash; this.betterHash = betterHash; this.showDistro = showDistro; this.put = put; this.get = get;}//console.log(new Array(10))function simpleHash(data){ var total = 0; for(var i =0;i&lt;data.length;i++){ total += data.charCodeAt(i); //返回每个字符的ASCCII码值 } console.log(&quot;Hash value :&quot; + data + &quot;-&gt;&quot; +total) return total % this.table.length;}function put(key,data){ // var pos = this.simpleHash(data); var pos = this.betterHash (key); this.table[pos] = data;}function showDistro(){ var n =0; for(var i=0;i&lt;this.table.length;i++){ if(this.table[i]!=undefined){ console.log(i + &quot;:&quot; +this.table[i]); } }}function betterHash(str){ const H =37; var total = 0; for(var i=0;i&lt;str.length;++i){ total += H*total + str.charCodeAt(i); } total = total % this.table.length; if(total&lt;0){ total += this.table.length-1; } return parseInt(total);}function get(key){ return this.table[this.betterHash[key]];}// var someNames = ['David',&quot;Jennifer&quot;,&quot;Donnie&quot;,&quot;Raymond&quot;,&quot;Cynthia&quot;,&quot;Mike&quot;,&quot;Clayton&quot;,&quot;Danny&quot;,&quot;Jonathan&quot;];// var hTable = new HashTable();// for(var i =0 ;i&lt;someNames.length;++i){// hTable.put(someNames[i]);// }// hTable.showDistro(); 二叉查找树 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163function Node(data,left,right){ this.data = data; this.count = 1; this.left = left; this.right = right; this.show = show; }function show(){ return this.data;}function BST(){ this.root = null; this.insert = insert; this.inOrder = inOrder; this.getMin = getMin; this.getMax = getMax; this.find = find; this.remove=remove; this.removeNode = removeNode;}function insert(data){ var n = new Node(data,null,null); if(this.root ==null){ this.root = n; }else{ var current = this.root; var parent; while(true){ parent = current; if(data&lt;current.data){ current = current.left; if(current == null){ parent.left = n; break; } }else{ current = current.right; if(current == null){ parent.right = n; break; } } } }}function inOrder(node){ if(!(node == null)){ inOrder(node.left); console.log(node.show()+&quot;&quot;); inOrder(node.right); }}function preOrder(node){ if(!(node == null)){ console.log(node.show() + &quot;&quot;) preOrder(node.left); preOrder(node.right); }}function postOrder(node){ if(!(node == null)){ postOrder(node.left); postOrder(node.right); console.log(node.show()+&quot;&quot;); }}function getMin(){ var current = this.root; while(!(current.left==null)){ current = current.left; } return current.data;}function getMax(){ var current = this.root; while(!(current.right==null)){ current = current.right; } //return current.data; return current;}function find(data){ var current = this.root; while(current != null){ if(current.data == data){ return current; }else if(data&lt;current.data){ current = current.left; }else{ current = current.right; } } return null;}function remove(){ root = removeNode(this.root,data);}function removeNode(node,data){ if(node == null){ return null; } if(data == node.data){ //没有子节点 if(node.left == null &amp;&amp; node.right == null){ return null; } //没有左子节点 if(node.left == null){ return node.right; } //没有you子节点 if(node.data == null){ return node.left; } //两个子节点 var temp= getSmallest(node.right); node.data = temp.data; node.right = removeNode(node.right,temp.data); return node; }else if(data&lt;node.data){ node.left = removeNode(node.left,data); return node; }else{ node.right = removeNode(node.right,data); return node; }}function update(date){ var grade = this.find(data); grade.count++; return grade;}//testvar nums = new BST();nums.insert(23);nums.insert(45);nums.insert(16);nums.insert(37);nums.insert(3);nums.insert(99);nums.insert(22);var min = nums.getMin();var max = nums.getMax();console.log(&quot;Inorder tranversal: &quot;);console.log(min,max);//inOrder(nums.root)//3 16 22 23 37 45 99//preOrder(nums.root) //23 16 3 22 45 37 99postOrder(nums.root); //3 22 16 37 99 45 23var found = nums.find(45);console.log(found);","link":"/2020/11/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84JavaScript%E5%AE%9E%E7%8E%B0/"},{"title":"前端知识点总结-CSS","text":"前端知识点总结——CSS好记性不如烂笔头！ 1.CSS的概述1.什么是CSS? 1CSS：Cascading Style Sheets层叠样式表，级联样式表（简称：样式表） 2.作用 1设置HTML网页元素的样式 3.HTML与CSS的关系 12HTML：负责内容的展示CSS：负责内容（元素）的修饰 4.HTML与CSS之间的使用原则 12W3C建议尽量使用CSS属性去取代HTML属性来修饰元素 2.CSS语法规范1.使用CSS样式的方式(重点) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 1.内联样式 又称为行内样式 特点：将CSS样式定义在HTML开始标记中 语法： &lt;ANY style=&quot;样式声明1；样式声明2&quot;&gt;&lt;/ANY&gt; 样式声明： 1.由样式属性和值来组成 2.属性名与值之间用 冒号 连接 3.多个样式声明之间用 分号 分割 常用的CSS样式属性 和 值： 1.设置文本颜色的属性和值 属性：color 值：合法的颜色值（英文） 2.设置背景颜色的属性和值 属性：background 值：合法的颜色值（英文） 3.设置文字大小的属性和值 属性：font-size 值：以px或pt为单位的数字 ex：font-size:30px; 2.内部样式 在网页的头元素中增加一对&lt;style&gt;标记，在&lt;style&gt;标记声明该网页用到的样式规则 语法： &lt;head&gt; &lt;style&gt; /*注释*/ 样式规则1 样式规则2 ... &lt;/style&gt; &lt;/head&gt; 样式规则：由选择器和样式声明组成选择器：规范了页面中哪些元素能够使用定义好的样式（就是把声明好的样式匹配给页面中的元素）元素选择器：由元素的名称作为选择器div,p,h1,span,a,img选择器{}ex：div{} p{}样式规则： 选择器{ 样式声明； }ex:div{ color:red; font-size:20px;}p{ color:blue;}h1{...} 3.外部样式 独立于任何网页的位置处，声明一个样式表文件（***.css为后缀）， 在.css文件中保存样式规则，然后在网页中引入.css文件。 使用步骤： 1.创建样式表文件，并编写样式规则 2.在网页中引入样式表文件 &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;**.css&quot;&gt; &lt;/head&gt; 3.CSS样式特征12345678910111213141516171819202122232425262728293031321.继承性 大部分样式可以被继承（子元素继承父元素的样式特征） 必须是有层级关系的嵌套 &lt;div style=&quot;color:red;&quot;&gt; &lt;p&gt;p&lt;/p&gt; &lt;/div&gt;2.层叠性 可以为一个元素定义多个样式，当样式属性不冲突时，可以同时将这些样式应用到元素上 div{ color:red; } div{ font-size:20px; } div{ background:gray; }3.优先级 如果样式声明冲突时，会按照样式的优先级来应用定义的样式规则 由低到高： 浏览器默认设置 最低 内部样式和外部样式 中(就近原则) 内联样式 最高4.调整显示的优先级 !important规则： 调整显示的优先级 将!important添加在属性值之后，与值之间用空格隔开，就能优先使用当前样式 ex: color:red !important; 4.CSS基础选择器（重点）123456789101112131.选择器的作用 规范页面中哪些元素能够使用定义好的样式2.选择器详解 1.通用选择器 作用：可以修饰页面上的任何元素语法：*{样式声明}效率较低，尽量少用ex: *{ color:red; font-size:40px; } 2.元素选择器 1234567 作用：设置页面上某种（类）元素的样式语法：标记名称{声明样式}ex： div{} p{} span{} 3.类选择器 1234567891011121314151617181920212223242526 作用：定义页面上某个或某些元素的样式(谁想用谁就可以引用)特点：通过元素的class属性进行引用语法： 1.声明 .类名{样式声明} 注意： 1.类名是自定义的，但是注意类名不能以数字开头 2.类名不能包含特殊符号（&amp;,^,%,$,#,@） 3.可以包含（_,-） 2.引用 &lt;ANY class=&quot;类名&quot;&gt; 特殊用法： 1.多类选择器 让一个元素同时引用多个类选择器 语法： &lt;ANY class=&quot;类名1 类名2 类名3 ...&quot;&gt; 2.分类选择器 将元素选择器和类选择器联合使用 对同一类元素中某些特殊的内容进行修饰 语法：元素名称.类选择器{样式声明} ex:div.text{color:red;} &lt;div class=&quot;text&quot;&gt;dddd&lt;/div&gt; &lt;div&gt;d1d1d1&lt;/div&gt; 4.id选择器 12345678作用：设置指定ID元素的样式（专属定制）语法：#id值{样式声明}ex: &lt;div id=&quot;one&quot;&gt;&lt;/div&gt; #one{ color:red; } 5.群组选择器 123456789作用：将多个选择器放在一起进行样式的声明定义语法：选择器1,选择器2,选择器3,...{样式声明} ex: div,#main,.mycolor,p.text{color:red;} 等同于： div{color:red}; #main{color:red}; .mycolor{color:red}; p.text{color:red}; 6.后代选择器 12作用：通过元素的后代关系匹配元素（多级嵌套）语法：选择器1 选择器2 选择器3{样式声明} 7.子代选择器 12作用：通过元素的子代（一层层级关系）关系匹配元素语法：选择器1&gt;选择器2{样式声明} 8.伪类选择器 1234567891011121314151617181920212223作用：匹配元素不同的状态的选择器语法： 所有的伪类都是以：作为开始 选择器：伪类选择器{样式声明}1.连接伪类 :link 匹配元素尚未访问的状态 :visited 匹配元素访问过的状态2.动态伪类 :hover 匹配鼠标悬停在元素上时的状态 :active 匹配元素被激活时的状态（超链接，文本框，密码框点击的时候） :focus 匹配元素获取焦点时的状态（文本框和密码框）3.选择器的优先级 权值：标识当前选择器的重要程度，权值越大优先级越高。 元素选择器：1类选择器： 10伪类选择器：10ID选择择器：100内联样式： 1000选择器的权值加到一起，大的优先权值相同，以后定义的为主 5.尺寸与边框1.单位 1234567891011121314151617181920212223242526272829303132331.尺寸单位 1.px：像素 1024*768 2.in:英寸 1in=2.54cm 3.pt：磅(1pt=1/72in) 多数用于表示文字的大小 4.cm:厘米 5.mm:毫米 6.em:相对于父元素乘以倍数(多个父元素2em) 7.rem:根相对（元素字体大小乘以倍数，html\\body）2.颜色单位（颜色取值） 1.英文单词 red,blue,gray,green,yellow,black.... 2.rgb(r,g,b) r:0-255g:0-255b:0-255 3.rgba(r,g,b,alpha) alpha:透明度，取值为0-1之间的小数，值越大，不透明度越高 4.#rrggbb 由6位16进制的数字\\字母表示一个颜色0-9或A-f#000000:黑色#ffffff:白色#eeeeee:灰色#ff11aa 5.#rgb是上面的缩写形式 #000:黑色#fff:白色#f1a 2.尺寸属性 1234567891011121314151617181920211.作用 设置元素的宽度和高度2.语法 1.宽度 width:宽度min-width:最小宽度max-width:最大宽度 2.高度 height：高度min-height:最小高度max-height:最大高度3.页面中哪些元素允许设置尺寸属性 1.所有的块级元素都允许设置尺寸 div,p,h1,h2..h6,ul,ol,dl,结构标记 2.本身具备width和height属性的行内元素是可以设置的 img,table 3.行内块允许设置尺寸 大部分的表单控件（单选按钮，复选框） 4.大部分的行内元素是无法设置尺寸 a,span,b,i,u,s等 3.溢出处理 123456789101112当内容多，元素区域小的时候，就会产生溢出的效果，默认都是纵向溢出。属性：overflow,overflow-x,overflow-y取值： 1.visible 可见的，默认值，溢出可见 2.hidden 隐藏的，溢出的内容全部隐藏，溢出内容不可见 3.scroll 显示滚动条，溢出时，可用 4.auto 自动，溢出时才显示滚动条并可用 4.边框 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475761.边框属性 1.简写方式 border:width style color; width:边框的宽度，以px为单位的数值 style:边框的样式 取值： solid:实线 dotted:虚线边框(点) dashed:虚线边框(线) color:边框的颜色 取值：合法的颜色值 transparent:透明色 注意： 取消边框：border:0;或border:none; 2.单边定义 只设置某一条边的边框属性：border-方向:width style color; 方向：top/bottom/left/right 上 下 左 右 3.单属性定义 只设置四条边框的一个属性属性：border-width/style/color:值； ex:border-width:3px; border-style:dotted; border-color:red; 4.单边单属性的定义 只设置某一个方向的某一个属性属性： border-方向-属性：值； 方向：top/bottom/left/right 属性：width/style/color ex： border-left-color:blue; border-right-style:solid; border-bottom-width:6px;2.边框倒角 将元素的直角倒换成圆角 属性：border-radius 取值： 1.以px为单位的数值 2.百分比 % 设置圆形（50%） 单角设置： border-top-left-radius:左上角 border-top-right-radius:右上角 border-bottom-left-radius:左下角 border-bottom-right-radius:右下角3.边框阴影 属性：box-shadow 取值：h-shadow v-shadow blur spread color inset h-shadow:阴影在水平方向的偏移距离，必须值 取值为正：阴影向右偏移 取值为负：阴影向左偏移v-shadow:阴影在垂直方向的偏移距离，必须值 取值为正：阴影向下偏移 取值为负：阴影向上偏移blur:阴影模糊距离，取值越大，模糊效果越明显，以px为单位的数值（可选值）spread:阴影的大小，指定要在基础阴影上扩充出来的大小，取值以px为单位的数值（可选值）color:阴影颜色（可选值）inset:将默认的外阴影改为内阴影（可选值）4.轮廓 轮廓指的是边框的边框，绘制于边框外围的一条线 属性： outline:width style color; widht:轮廓的宽度 style:轮廓的样式 取值：solid/dotted/dashed color:轮廓的颜色 取消轮廓： outline:none/0; 6.框模型1.什么是框模型 1234567框模型：box model,定义了元素框处理元素的内容，内边距，外边距以及边框的一种计算方式。外边距：元素与元素之间的空白间距内边距：元素边框与元素内容之间的间距框模型的计算模式： 元素的实际占地宽度=左右外边距+左右边框+左右内边距+width;元素的实际占地高度=上下外边距+上下边框+上下的内边距+height 7.外边距1.什么是外边距 12围绕在元素边框外的空白距离，就是外边距也能表示当前元素与其他元素之间的空白距离 2.语法 123456789101112131415161718192021222324252627282930属性： margin 定义某个元素四个方向的外边距 margin-top/bottom/left/right 定义单边的外边距取值： 1.具体数值，以px为单位 2.取值为负 让元素向相反的方向移动 margin-left: 取值为正，让元素向右移动 取值为负，让元素向左移动 margin-top: 取值为正，让元素向下移动 取值为负，让元素向上移动 3.取值为% 外边距的值，是父元素的宽或高的占比（50%） 4.取值为auto 自动计算外边距的值（控制块级元素水平居中对齐）简写方式： 1.margin:value 四个方向的外边距2.margin:v1 v2; v1:上下外边距 v2:左右外边距3.margin:v1 v2 v3; v1:上外边距 v2:左右外边距 v3:下外边距3.margin:v1 v2 v3 v4; 上 右 下 左 （顺时针方向） 3.自带外边距的元素 12345body,h1~h6,p,ul,ol,dl,dd,pre通过CSS Reset(css重写)的手段，来重置具备外边距的元素 body,h1,h2,h3,h4,h5,h6,ul,ol,dl,dd,pre{ margin:0; } 4.外边距的特殊效果 12345678910111213141516171819201.外边距合并 当两个垂直外边距相遇时，他们将合并为一个，最终取决于两个外边距中距离较大的那个。 如果两个外边距相遇时值相等，那么取其中一个值。2.外边距的溢出 在某些条件下，为子元素设置上外边距时，有可能会作用到父元素上。 1.父元素没有上边框 2.为子元素设置上外边距时2.在d2中嵌套一个子元素div,id=&quot;d3&quot;,设置其尺寸为100*100，并设置其背景颜色3.设置d3的上外边距为50px,观察其结果。 解决溢出方案： 1.为父元素增加上边框 弊端：对父元素的高度有影响2.使用父元素的上内边距来取代子元素的上外边距 弊端：对父元素的高度有影响3.在父元素的第一个子元素位置处，增加一个空(table) 行内元素以及行内块元素的垂直外边距 1.行内元素垂直外边距无效（img除外） 2.行内块元素，设置垂直外边距时，整行元素都跟着发生改变 8.内边距1.什么是内边距 12元素边框与内容之间的空白距离内边距会扩大元素边框占地区域 2.语法 123456789101112131415161718属性： padding 四个方向的内边距 padding-top/bottom/left/right 设置单边内边距取值： 以px为单位的数值 以%形式设置简写方式： 1.padding:value; 四个方向的内边距 2.padding:v1 v2; v1:上下内边距 v2:左右内边距 3.padding:v1 v2 v3; v1:上 v2:左右 v3:下 4.padding:v1 v2 v3 v4; 上 右 下 左 （顺时针） 9.属性：box-sizing作用：指定框模型的计算方式 12345678910取值： 1.content-box 默认值，采用默认的计算元素的占地区域 实际占地宽度=左右边框+左右外边距+左右内边距+width; 实际占地高度=上下边框+上下外边距+上下内边距+height; 2.border-box 元素的尺寸，会包含border以及padding的值 实际占地宽度=width(包含了border和padding) 实际占地高度=height(包含了border和padding) 3.背景属性背景：可以是单一颜色或图片填充元素1.背景色 123属性：background-color取值：合法的颜色值注意：背景颜色默认是从边框的位置处开始填充的 2.背景图片 123属性：background-image取值：url(图片的路径);ex:background-image:url(a.jpg); 3.背景图片平铺 123456属性：background-repeat取值： repeat 默认值，横向纵向都平铺 no-repeat 不平铺（图片只显示一次） repeat-x 只在水平方向平铺 repeat-y 只在垂直方向平铺 4.背景图片尺寸 12345678属性：background-size取值： 1.width/height (ex:200px 300px) 2.width%/height% (ex:50% 50% 是元素自己的高宽占比) 3.cover 将背景图等比放大，直到背景图完全覆盖到元素的所有区域为止。 4.contain 将背景图等比放大，直到背景图碰到元素的某一个边缘为止 5.背景图片固定 123456作用：将背景图固定在网页的某个位置处，一直在可视区域中，不会随着滚动条而发生位置的变化。属性：background-attachment取值： 1.scroll 默认值，滚动 2.fixed 固定 6.背景图片定位 123456789101112131415161718192021作用：改变背景图在元素中的位置属性：background-position取值： 1.x y 具体的数值（px） x: 背景图水平偏移距离 取值为正，向右移动 取值为负，向左移动 y: 背景图垂直偏移距离 取值为正，向下移动 取值为负，向上移动 2.x% y% 0% 0% 背景图在左上角 100% 100% 背景图在右下角 50% 50% 背景图在中间位置 3.关键字 x:left/center/right y:top/center/bottom ex:background-position:right top; 7.背景简写属性 12345678在一个属性中指定背景的多个属性值属性：background取值：color url() repeat attachment positionex： background:gray url(a.jpg);注意： 如果不设置其中某个属性值的话，该位置采用默认值。 8.渐变1.什么是渐变 1渐变指定是多种颜色平缓变换的一种显示效果。 2.渐变的主要因素 121.色标：一种颜色及其出现的位置2.一个渐变是由多个色标组成（至少两个） 3.渐变分类 1234561.线性渐变 以直线的方向来填充效果2.径向渐变 以圆形的方式来实现填充3.重复渐变 将线性渐变或径向渐变 重复几次实现填充 4.渐变详解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501.线性渐变 属性：background-image 取值：linear-gradient(angle,color-point1,color-point2,....); 1.angle 表示渐变填充的方向或角度 取值： 1.关键字 to top 从下向上填充渐变色 to bottom 从上向下填充渐变色 to left 从右向左填充渐变色 to right 从左向右填充渐变色 2.角度值 0deg 从下向上填充，等同于to top 90deg 从左向右填充，等同于to right 180deg 从上到下填充，等同于to bottom 270deg 从右向左填充，等同于to left 2.color-point 色标：颜色 及其 位置 取值：颜色 以及 位置的组合，中间用空格分开 ex: 1.red 0% 在填充方向的开始位置处颜色为红色 2.green 50% 到填充方向一半的位置处，颜色变为绿色 3.blue 200px 到填充方向的200px的位置处，颜色变为蓝色2.径向渐变 属性： background-image:radial-gradient([size at position], color-point1,color-point2,...); size at position: size:半径，以px为单位的数值 position:圆心所在位置 1.x y 具体数值 2.x% y% 元素宽和高的占比 3.关键字 x:left,center,right y:top,center,bottom ex： 100px at right top 半径 右上角位置3.重复渐变 1.重复线性渐变 background-image:repeating-linear-gradient (angle,color-point1,color-point2,...);color-point:位置一定要给绝对数值（px）,不要用相对单位% 2.重复径向渐变 background-image:repeating-radial-gradient ([size at position],color-point1,color-point2,...); 9.浏览器兼容性1234567 各个浏览器的新版本都支持渐变属性对于不支持的浏览器版本，可以通过增加浏览器前缀的方式，让浏览器支持渐变属性Firefox:-moz-Chrome &amp; Sagari:-webkit-Opera:-o-IE:-ms- 2.文本格式化属性1.字体属性 1234567891011121314151617181920212223242526272829303132333435361.指定字体 属性：font-family 取值：字体名称，名称之间用逗号隔开 ex： font-family:&quot;微软雅黑&quot;,Arial,&quot;黑体&quot;;2.字体大小 属性：font-size 取值：以px或pt为单位的数字3.字体加粗 属性：font-weight 取值： 1.bold 加粗（b,hn） 2.normal 正常 3.value 无单位的数字（整百倍） 400-900 400：等同于normal 900：等同于bold4.字体样式 属性：font-style 取值： 1.normal 正常显示 2.italic 斜体显示5.小型大写字母 将小写字符变成大写，但文本的大小与小写字符一致 属性：font-variant 取值： 1.normal 正常 2.small-caps 小型的大写字符6.字体属性简写 属性：font 取值：style variant weight size family; 注意： 如果用简写方式，必须设置family的值，否则无效。font:12px; 错误font:12px &quot;黑体&quot;; 正确 2.文本格式 12345678910111213141516171819202122232425261.文本颜色 属性：color 取值：合法的颜色值2.文本排列 作用：指定文本，行内，行内块元素的水平对齐方式。 属性：text-align 取值：left/center/right/justify(两端对齐)3.文字修饰（线条） 属性：text-decoration 取值： none:无任何线条修饰underline:下划线修饰overline:上划线修饰 line-through:删除线修饰4.行高 作用:定义一行文本的高度 特点：如果行高的高度大于字体本身的大小，那么该行文本将在指定的行高内呈现垂直居中的效果。 属性:line-height 取值：以px为单位数值5.首行文本缩进 属性：text-indent 取值：以px为单位的数值6.文本阴影 属性：text-shadow 取值：h-shadow v-shadow blur color; 10.表格1.表格的常用属性 12345678910111213141516171.边距属性：padding2.边框属性：border3.尺寸属性：width,height4.文本格式化属性：font-*,text-*,line-height5.背景属性：颜色，图片，渐变6.vertical-align 作用：指定单元格数据垂直对齐方式 取值： top:上对齐 middle:居中对齐 bottom:下对齐 练习：创建网页，并在网页中添加表格 1.表格尺寸为400*400，4行4列; 2.每个单元格的尺寸为100*100,内容随意; 3.设置表格和单位元格的边框为1px solid #000; 4.设置每个单元格的左内边距为20px; 5.尝试为每个单元格增加上外边距15px。 2.表格的特殊属性 12345678910111213141516171.边框合并 取值：border-collapse 取值： 1.separate 默认值，即分离边框模式 2.collapse 边框合并2.边框边距 作用：设置单元格之间或单元格与表格之间的距离 属性：border-spacing 取值： 1.给定一个值：水平和垂直的间距相同2.给两个值： 第一个值 表示水平间距 第二个值 表示垂直间距注意：只有在边框分离模式下，边框边距才有效果，即border-collapse:separate时，border-spacing才有效。 3.表格标题位置 12345属性：caption-side取值： 1.top:默认值，标题在表格内容之上2.bottom:标题在表格内容之下 4.显示规则 12345678910111213141516171819作用：用来帮助浏览器指定如何布局一张表，也就是指定td尺寸的计算方式。属性：table-layout取值： 1.auto 默认值，即自动布局表格，列的尺寸实际上由内容来决定的。 2.fixed 固定表格布局，列的尺寸由设置的值为准自动表格布局VS固定表格布局： 1.自动表格布局 1.单元格的大小会适应内容 2.表格复杂时，加载速度较慢（缺点） 3.自动表格布局会比较灵活（优点） 4.适用于不确定每列大小时使用 2.固定表格布局 1.单元格的尺寸取决于设定的值 2.任何情况下都会加载显示表格（优点） 3.适用于确定每列大小时使用 4.固定表格布局不够灵活（缺点） 11.定位-浮动定位1.定位 1定位：指的是改变元素在页面中的默认位置 2.定位的分类 123456按照定位的效果，可以分成以下几类： 1.普通流定位（默认的定位方式） 2.浮动定位 3.相对定位 4.绝对定位 5.固定定位 3.定位详解 12345678910111213141516171819202122231.普通流定位 又称为文档流定位，页面中元素的默认定位方式 1.每个元素在页面中都有自己的空间 2.每个元素默认都是在其父元素的左上角开始显示 3.页面中的块级元素都是从上往下排列，每个元素独占一行 4.页面中的行内元素以及行内块都是按照从左到右的顺序来排列的 要解决的问题：让多个块级元素在一行中显示2.浮动定位 1.什么是浮动&amp;特点 1.元素一旦浮动起来，将不占据页面空间（脱离了文档流），其它未浮动元素将上前补位。2.浮动元素会停靠在父元素的左边或右边，或其它已经浮动的元素的边缘上。3.浮动定位解决的问题：能够让多个块级元素在一行中显示。 2.语法 属性：float取值： 1.left 左浮动，让元素停靠在父元素的左边或挨着左侧已经浮动的元素 2.right 右浮动，让元素停靠在父元素的右边或挨着右侧已经浮动的元素 3.none 默认值，即无任何浮动效果 12.浮动引发的特殊效果1.元素一旦浮动起来以后就会变成块级元素 12允许修改尺寸能正常处理垂直方向外边距 2.当父元素显示不下所有已浮动元素时，最后一个将换行，但是，有可能被卡住；3.元素一旦浮动起来后，宽度将以内容为主（未指定宽度情况下）；4.文本，行内元素，行内块元素是采用环绕的方式来排列的，是不会别浮动元素压在底下的，而会巧妙的避开浮动元素。 13.清除浮动带来的影响元素一旦浮动起来之后，就会对后续元素带来一定的位置影响（后续元素要上前补位），如果后续元素不想被影响（不想补位），那么就可以通过清除浮动的方式来解决属性：clear取值： 1234567891.left 清除当前元素前面的元素左浮动所带来的影响2.right 清除当前元素前面的元素右浮动所带来的影响3.both 清除当前元素前面元素任何一种浮动所带来的影响4.none 默认值，不做任何的清除浮动操作 14.浮动元素对父元素高度的影响1.元素的高度都是以未浮动元素的高度为准的，浮动元素是不占页面的高度的 12345678910 解决父元素的高度方案如下： 1.直接设置父元素的高度 弊端：不是每次都知道父元素的高度2.设置父元素也浮动 弊端：不是任何时候父元素都需要浮动，而且浮动会影响后续元素3.为父元素设置overflow 取值：hidden或auto 弊端：如果有内容需要溢出显示的话，也会一同被隐藏4.在父元素中，追加空子元素(块级)，并设置其clear:both; 15.显示1.显示方式 123456789101112131415161718192021222324252627281.什么是显示方式 决定了元素在网页中的表现形式（块级，行内，行内块）2.语法 属性：display 取值： 1.none 不显示元素-隐藏 特点：脱离文档流，不占据页面空间 2.block 让元素表现的和块级元素一致 特点： 独占一行，可是修改高宽 3.inline 让元素表现的和行内元素一致 特点： 不允许修改尺寸 多个元素在一行中显示 无法设置垂直外边距 4.inline-block 让元素表现的和行内块元素一致 特点： 多个元素在一行中显示，但是可以修改尺寸 5.table 让元素表现的与表格一致 特点： 尺寸以内容为准 每个元素独占一行 允许修改尺寸 2.显示效果 12345678910111213141516171819202122231.显示/隐藏 属性：visibility 取值： 1.visible:默认值，元素可见 2.hidden:元素不可见-隐藏 面试：display:none和visibility:hidden的区别 display:none 不占页面空间 visibility:hidden 占页面空间2.透明度 属性：opacity 取值：0.0（完全透明）~1.0（完全不透明）之间的小数3.垂直方向对齐方式 属性：vertical-align 场合： 1.表格中使用 取值：top/bottom/middle 2.图片（img）中使用 取值： top：上 bottom：下 middle：中间 baseline:基线对齐，默认值 16.光标1.作用 1改变鼠标悬停在元素上时，鼠标的状态 2.语法 1234567891011属性：cursor取值： 1.default: 默认2.pointer: 小手3.crosshair: +4.text: I5.wait: 等待6.help: 帮助 练习： 新建一个div元素，当鼠标移入到div上时，让光标变成小手状态。 17.列表1.列表项标记 123456属性：list-style-type取值： 1.none 2.disc 3.circle 4.square 2.列表项图像 123作用：使用自定义图像作为列表项标识属性：list-style-image取值：url(图像路径); 3.列表项位置 12345作用：将默认的列表项标识的位置，放到li里面属性：list-style-position取值： 1.outside 默认值，将标识显示在li外面的 2.inside 将标识放于li里面 4.列表属性简写 123456属性：list-style取值：type url() position;常用方式：list-style:none;列表的使用场合： 横向排列或纵向排列的内容，都可以使用列表来实现。 18.定位相对定位，绝对定位，固定定位1.定位相关属性 123456属性：position取值： 1.static:静态，默认值 2.relative:相对定位 3.absolute:绝对定位 4.fixed:固定定位 2.偏移属性 12345678top/bottom/left/right以上四个属性的取值均为数字ex: top:150px 元素向下移动150px left:20px 元素向右移动20px right:-150px 元素向右移动150px注意： 只有已定位元素才能使用偏移属性 3.定位详解 12345678910111213141516171819202122232425262728293031323334353637383940414243441.相对定位 1.什么是相对定位 元素相对于它原来的位置偏移某个距离 2.使用场合 做元素位置微调时使用 3.语法 position:relative; 配合偏移属性来实现位置的移动 left:10px; top:10px;2.绝对定位 1.什么是绝对定位&amp;特点 1.绝对定位的元素会脱离文档流-不占页面空间2.绝对定位的元素会相对于离他最近的，已定位的，祖先元素 去实现位置的初始化。3.如果没有已定位的祖先元素，那么该元素就相对于body去实现位置的初始化4.配合偏移属性 实现元素位置的修改 2.语法 position:absolute;配合偏移属性实现位置的修改 3.使用场合 1.有堆叠效果的元素2.弹出菜单 4.注意： 1.脱离文档流-不占据页面空间2.绝对定位元素会变成块级元素 5.堆叠顺序 一旦元素变为已定位元素的话，元素们则有可能出现堆叠的效果属性：z-index取值：无单位的数字，数字越大越靠上 注意： 1.只有已定位元素才能实现堆叠顺序的改变（z-index） 2.父子元素间，z-index无效，永远都是子元素压在父元素上方3.固定定位 1.什么是固定定位 将元素固定在网页的某个位置处，位置不会随着滚动条而发生改变，固定在可视区域中。 2.语法 position:fixed;配合偏移属性使用 注意： 1.固定定位的元素永远都是相对于body去实现位置的初始化和偏移。2.固定定位的元素会变成块级元素3.固定定位元素会脱离文档流-不占页面空间","link":"/2020/09/25/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-CSS/"},{"title":"前端知识点总结-JS基础","text":"前端知识点总结——JS基础好记性不如烂笔头！ 1.javascript概述(了解)1.什么是javascript 1234javascript简称为js，是一种运行于js解释器/引擎中的脚本语言js的运行环境：1.独立安装的js解释器（node）2.嵌入在浏览器内核中的js解释器 2.js的发展史 12341.1992年Nombas公司为自己开发了一款脚本语言SciptEase2.1995年Netscape(网景)开发了一款脚本语言LiveScrpt,后来更名javascript3.1996年Microsoft在IE3.0版本中克隆javascript，JScript4.1997年，javascript提交给ECMA(欧洲计算机制造商联合会)。定义ECMAScript,简称ES5，ES6 3.js组成部分 1231.核心（ECMAScript）2.DOM (Document object model)文档对象模型3.BOM (Browser object model)浏览器对象模型 4.js的特点 123451.语法类似于c,java2.无需编译，由js解释器直接运行3.弱类型语言4.面向对象的 2.JavaScript的基础语法1.使用javascript 1234567891011121314151617181920212223242526272829303132333435363738391.搭建运行环境 1.独立安装的JS解释器-NodeJS 1.在命令行界面：输入node console.log(&quot;你好，世界&quot;); 在控制台打印输出 说明：js是可以独立在js解释器中运行2.使用浏览器内核中嵌的js解释器 浏览器内核负责页面内容的渲染，由两部分组成： 内容排版引擎-解析：HTML/CSS 脚本解释引擎-解析：javascript 1.直接在Console（控制台）中输入脚本并运行 2.将js脚本嵌入在HTML页面中执行 1.html元素的事件中执行js脚本 事件-onclick-鼠标单击时要执行的操作 2.在&lt;script&gt;中编写脚本并执行 网页的任何位置处，嵌入一对&lt;script&gt;标记，并且将脚本编写在&lt;script&gt;标记中。 3.使用外部脚本文件(.js为后缀) 1.创建脚本文件（.js）并在文件中编写脚本 2.在使用的网页中引用脚本文件 &lt;script src=&quot;脚本文件的url&quot;&gt;&lt;/script&gt; 3.js调试，F12查看错误，出错时不影响其它代码块，后续代码继续执行。 &lt;script&gt; /*这个脚本错误*/ document.writ(&quot;&lt;h3&gt;周芷若&lt;/h3&gt;&quot;); &lt;/script&gt; &lt;script&gt; /*继续执行*/ console.log(&quot;金花婆婆&quot;); &lt;/script&gt; 3.通过语法规范 1.语句：可执行的最小单元 必须以;结束 严格区分大小 所有的符号必须是英文 2.注释: // :单行注释 /**/:多行注释 3.变量和常量1.变量声明 1234567891011121314151.声明变量 var 变量名;2.为变量赋值 变量名=值;3.声明变量是直接赋值 var 变量名=值; ex： var uname=&quot;张无忌&quot;; var age=20; 注意： 1.允许在一条语句中声明多个变量，用逗号隔开变量名。 var uname=&quot;韩梅梅&quot;,uage=20; 2.如果声明变量，但未赋值，则值默认为undefined 3.声明变量时可以不适用var,但不推荐 uname=&quot;tom&quot;; 2.变量名的规范 123456789101112131.不允许以数字开头2.不允许使用关键词和保留关键字3.最好见名知意 var uname; var uage;4.允许包含字母，数字，下划线(_),$ var $name=&quot;Tom&quot;;5.尽量使用小驼峰命名法 var userName; var uname; var _uname;//下划线 var user_name;//下划线 var UserName;//大驼峰命名法 4.变量的使用12345678910111.声明变量未赋值，值默认为undefined2.使用未声明过的变量 报错3.赋值操作 变量名出现在=的左边，一律是赋值操作 var uname=&quot;林妹妹&quot;;4.取值操作 变量只要没出现在=的左边，一律是取值操作 var uage=30;console.log(uage);var num1=uage; 5.常量12345671.什么是常量 在程序中，一经声明就不允许被修改的数据就是常量。2.语法 const 常量名=值; 常量名在程序中，通常采用大写形式。 const PI=3.1415926; 5.1数据类型1.数据类型的作用 12345678规定了数据在内存中所占的空间10.1 64位 8个字节bit:位8bit=1byte字节1024byte=1KB 1024KB=1MB1024MB=1G 1024G=1T 2.数据类型详解 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374751.数据类型分两大类 原始类型（基本类型） 引用类型 1.原始类型 1.Number 类型 数字类型 作用：可以表示32位的整数，也可以表示64位的浮点数（小数） 整数： 1.十进制 10 2.八进制 由0-7八个数字组成，逢八进一 八进制中以0开始 var num=010; 3.十六进制 由0-9和A-f组成，逢十六进一 A:10 B:11 C:12 D:13 E:14 F:15 十六进制中以0X开始 浮点数：又称小数 小数点计数法：12.58 指数计数法：3.4e3（3.4*10的3次方）2.String类型 字符串类型 作用：表示一系列的文本字符数据，如：姓名，性别，住址... 字符串中的每个字符，都是由Unicode码的字符，标点和数字组成。 Unicode码:每个字符在计算机中都有一个唯一的编码表示该字符， 该码就是unicode码（他是十六进制） 1.查找一个字符的unicode码： &quot;李&quot;.charCodeAt(); //10进制输出 &quot;李&quot;.charCodeAt().toString(2); //二进制输出 &quot;李&quot;.charCodeAt().toString(16); //十六进制 李的unicode码是：674e 2.如何将674e转换为汉字？ 用\\u ex: var str=&quot;\\u674e&quot;; console.log(str);//结果是“李” 汉字的Unicode码的范围： \\u4e00~\\u9fa5 3.特殊字符需要转义字符 \\n: 换行 \\t: 制表符（缩进） \\&quot;: &quot; \\': ' \\\\: \\3.Boolean类型 布尔类型 作用：在程序中表示真或假的结果 取值： true或false var isBig=true; var isRun=false; 在参与到数学运算时，true可以当成1做运算，false可以当做0做运算。 var res=25+true; //结果为26 4.Undefined类型 作用：表示使用的数据不存在 Undefined类型只有一个值,即undefined当声明的变量未赋值（未初始化）时， 该变量的默认值就是undefined.5.Null类型 null用于表示不存在的对象。 Null类型只有一个值，即null,如果函数或方法要返回的是对象， 找不到该对象，返回的就是null。 5.2数据类型的转换12345678910111213141516171819202122232425262728293031323334353637383940411.隐式（自动）转换 不同类型的数据在计算过程中自动进行转换 1.数字+字符串：数字转换为字符串 var num=15;var str=&quot;Hello&quot;;var res=num+str; //结果：15Hello 2.数字+布尔：将布尔转换为数字true=1,false=0 var num1=10;var isSun=true;var res1=num1+isSun;//结果：11 3.字符串+布尔：将布尔转换为字符串 var str1=&quot;Hello&quot;;var isSun1=true;var res2=str1+isSun1;//结果：Hellotrue 4.布尔+布尔：将布尔转换为数字 true=1,false=0; var isSun2=true;var isSun3=flase;var res=isSun2+isSun3;//结果12.强制转换 -转换函数 1.toString() 将任意类型的数据转换为字符串语法： var num=变量.toString(); ex: var num=15; var str=num.toString(); console.log(typeof(str)); 2.parseInt() 将任意类型的数据转换为整数如果转换不成功，结果为NaN(Not a Number)语法：var result=parseInt(数据); 3.parseFloat() 将任意类型的数据转换为小数如果转换不成功，结果为NaN语法：var result=parseFloat(数据); 4.Number() 将任意类型数据转为Number类型注意：如果包含非法字符，则返回NaN语法：var result=Number(数据); 6.运行符和表达式1.什么是表达式 12345由运算符连接操作数所组成的式子就是表达式。ex： 15+20 var x=y=40任何一个表达式都会有结果。 2.运算符 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394951.算术运算符 +，-，*，/，%，++，-- 5%2=1; ++:自增运算，只做+1操作 ++在前：先自增，再运算； ++在后：先运算，再自增； ex: var num=5;console.log(num++);//打印5，变为6console.log(++num);//变为7，打印7ex: var num=5; 5 (6)6 6(7) (8)8 var res=num+ ++num +num++ + ++num +num++ +num; 8(9) 9结果：422.关系运算符（比较） &gt;,&lt;,&gt;=,&lt;=,==,===(全等),!=,!==(不全等) 关系运算的结果：boolean类型（true,false） 问题： 1. 5 &gt; &quot;10&quot; 结果：false 关系运算符两端，只要有一个是number的话，另外一个会隐式转换为number类型，再进行比较。2.&quot;5&quot;&gt;&quot;1 0&quot; 结果：true &quot;5&quot;.charCodeAt(); //53 &quot;1&quot;.charCodeAt(); //49 &quot;张三丰&quot; &gt; &quot;张无忌&quot; 结果：false 19977 &gt; 260803.&quot;3a&quot; &gt; 10 结果：false Number(&quot;3a&quot;)---&gt;NaN 注意： NaN与任何一个数据做比较运算时，结果都是false. console.log(&quot;3a&quot;&gt;10); false console.log(&quot;3a&quot;==10); false console.log(&quot;3a&quot;&lt;10); false isNaN()函数： 语法：isNaN(数据); 作用：判断指定数据是否为非数字，如果不是数字，返回值为true,是数字的话返回的值为false console.log(isNaN(&quot;3&quot;)); //false console.log(isNaN(&quot;3a&quot;)); //ture console.log(&quot;3a&quot;!=10);//true3.逻辑运算符 !,&amp;&amp;,|| !:取反 &amp;&amp;：并且，关联的两个条件都为true,整个表达式的结果为true ||:或者，关联的两个条件，只要有一个条件为true,整个表达式的结果就为true 短路逻辑： 短路逻辑&amp;&amp;： 当第一个条件为false时，整体表达式的结果就为false,不需要判断第二个条件 如果第一个条件为true,会继续判断或执行第二个条件 短路逻辑||： 当第一个条件为true时，就不再执行后续表达式，整体结果为true。 当第一个条件为false时，继续执行第二个条件或操作。4.位运算符 &lt;&lt;,&gt;&gt;,&amp;,|,^ 右移是把数变小，左移是把数变大 &amp;：按位与，判断奇偶性 任意数字与1做按位与，结果为1，则为奇数，结果为0，则为偶数。 var num=323; var result=num &amp; 1 console.log(result); //结果为1 |：按位或，对小数取整 将任意小数与0做按位或，结果则取整数部分。 ^：按位异或，用于交换两个数字 二进制位数，逐位比较，不同则为1，相同则为0 a=a^b; b=b^a; a=a^b;5.赋值运算符和扩展赋值运算符 1.赋值运算 = var uname=&quot;TOM&quot;; 2.扩展赋值运算符 +=,-=,*=,/=,%=,^=...a=a+1 a+=1;a++;++aa=a^ba^=b6.条件（三目）运算符 单目（一目）运算符，只需要一个操作数或表达式 ex: a++,b--,!isRun 双目（二元）运算符，需要两个操作数或表达式 +，-，*，/，%，&gt;,&lt;,&gt;=,&lt;=,==,!=,===,!==,&amp;&amp;,||,&amp;,|,^ 三目（三元）运算符，需要三个操作数或表达式 条件表达式？表达式1:表达式2; 先判断条件表达式的值， 如果条件为true,则执行表达式1的操作 如果条件为false,则执行表达式2的操作 ex:成绩大于60及格，否则，输出不及格 7.函数-function1.什么是函数 123456789101112函数，function,也称为方法（method）函数是一段预定义好，并可以被反复执行的代码块。 预定义：提前定义好，并非马上执行。 代码块：可以包含多条可执行的语句 反复执行：允许被多次调用函数-功能 parseInt(); parseFloat(); Number(); console.log(); alert(); document.write(); 2.定义和使用函数 1234567891011121314151617181920212223242526272829303132331.普通函数的声明和调用（无参数无返回值） 1.声明 function 函数名(){ //函数体 若干可执行的语句} 2.调用函数 在任意javascript合法的位置处通过 函数名(); 对函数进行调用。2.带参函数的声明和调用 1.声明 function 函数名(参数列表){ //函数体}参数列表：可以声明0或多个参数，多个参数间用逗号隔开声明函数时，声明的参数，称之为“形参” 2.调用 函数名(参数值列表); 注意：调用函数时，传递的参数数值，称之为“实参”。 尽量按照声明函数的格式进行调用3.带返回值函数声明和调用 1.声明 function 函数名(参数){ //函数体 return 值; //return关键字，程序碰到return关键词，就立马跳出并且把值带出去}注意：最多只能返回一个值 2.调用 允许使用一个变量接收函数的返回值 var result=函数名(实参); 8.作用域12345671.什么是作用域 作用域表示的是变量或函数的可访问范围。 JS中的作用域分两种： 1.函数作用域 只在函数范围内有效 2.全局作用域 代码的任何位置都有效 2.函数作用域中变量 123456又称为局部变量，只在声明的函数中有效ex： function test(){ var num=10; } 3.全局作用域中的变量 1234567891011又称为全局变量，一经声明，任何位置都能用1.不在function中声明的变量，为全局变量2.声明变量不使用var，无论任何位置声明，都是全局变量（不推荐）注意： 全局变量和局部变量冲突时，优先使用局部变量。3.变量的声明提前 1.什么是声明提前 在JS程序正式执行之前，function声明的函数， 会将所有var声明的变量，都预读（声明）到所在作用域的顶部，但赋值还是保留在原位。 9.按值传递1.什么是按值传递 1234原始（基本）类型的数据（number,string,bool）,在做参数传递时，都是按照“值传递”的方式进行传参的。值传递：真正传递参数时，实际上传递的是值的副本（复制出来一个值），而不是原始值。 2.函数的作用域 12345671.分为两种 1.局部函数 在某个function中声明的函数。 2.全局函数 在最外层(&lt;script&gt;中)定义的函数就是全局函数，全局函数一经定义， 任何位置处都能调用。 10.ECMAScript提供一组全局函数1.parseInt()2.parseFloat()3.isNaN()4.encodeURI() 12345URL:uniform resource locator路径URI:uniform resource Identifier作用：对统一资源标识符进行编码，并返回编码后的字符串所谓的进行编码，就是将地址中的多字节文字编成单字节的文字（英文数字：单字节，汉字2-3字节不等） 5.decodeURI() 1作用：对已经编码的URI进行解码，并返回解码后的字符串。 6.encodeURIComponent() 1在encodeURI的基础上，允许对特殊符号进行编码。 7.decodeURIComponent() 1解码特殊符号 8.eval() 12作用：执行以字符串表示的js代码 11.递归调用递归：在一个函数的内部再一次调用自己问题： 12345678910111213141516171*2*3*4*55*4*3*2*1求5!(5*4*3*2*1) 4!(4*3*2*1) 3!(3*2*1) 2!(2*1) 1!(1*1) 5!=5*4! 4!=4*3! 3!=3*2! 2!=2*1! 1!=1 通过一个函数，求数字n的阶乘 10！=10*(10-1)！ 效率： 在本次调用还未结束时，就开始下次的调用，本次调用就会被挂起， 直到所有的调用都完成之后，才会依次返回，调用的次数越多，效率越低。 12.分支结构1.if结构 12345678910111213if(条件){ 语句块；}注意： 条件尽量是boolean的，如果不是boolean,以下情况会当做false处理 if(0){...} if(0.0){...} if(&quot;&quot;){...} if(undefined){...} if(null){...} if(NaN){...}注意：if后的{}可以省略，但是不推荐，只控制if后的第一句话。 2.if…else…结构 123456语法： if(条件){ 语句块 }else{ 语句块 } 3.if….else if…else… 1234567891011语法： if(条件1){ 语句块1 }else if(条件2){ 语句块2 }else if(条件3){ 语句块3 }else{ 语句块n } 4.switch…case 1234567891011121314151617181920212223241.作用：（使用场合） 等值判断2.语法 1.switch(值/表达式){ case 值1： 语句块1； break;//结束switch结构，可选的 case 值2： 语句块2； break; ... default: 语句块n； break; } 2.特殊用法 执行相同操作时： switch(值/表达式){ case 值1： case 值2： case 值3： 语句块； } 12.循环结构1.特点 121.循环条件：循环的开始和结束2.循环操作：要执行的相同或相似的语句 2.循环-while 1234567语法： while(条件){ //循环体-循环操作 //更新循环条件 } 3.循环的流程控制 12345671.break 作用：终止整个循环的运行2.continue 作用：终止本次循环的运行，继续执行下一次循环 ex: 循环从弹出框中录入信息，并且打印，直到输入exit为止。 4.循环-do…while 12345678910111.语法 do{ //循环体 }while(条件); 执行流程： 1.先执行循环体 2.再判断循环条件 如果条件为真，则继续执行循环体 如果条件为假，则跳出循环操作 5.循环-for 1234567891011121314151617语法： for(表达式1;表达式2;表达式3){ //循环操作 } 表达式1：循环条件的声明 表达式2：循环条件的判断 表达式3：更新循环变量 执行流程： 1.先执行表达式1 2.判断表达式2的结果(boolean类型) 3.如果2条件为真，则执行循环体，否则退出 4.执行完循环体后，再执行表达式3 5.判断表达式2的结果 ex: for(var i=1;i&lt;=10;i++){ console.log(i); } 13.for的特殊用法1.for(表达式1;表达式2;表达式3;){} 123451.省略表达式 三个表达式可以任意省略，分号不能省 但一定在循环的内部或外部将表达式补充完整2.表达式1和表达式3 允许写多个表达式，用逗号隔开表达式 14.循环嵌套1.循环嵌套 12345678在一个循环的内部，又出现一个循环 for(var i=1;i&lt;100;i++){ //外层循环 for(var j=1;j&lt;=10;j++){ //内层循环 } } 外层循环走一次，内层循环走一轮 15.数组1.什么是数组 1234在一个变量中保存多个数据。数组是按照线型顺序来排列的-线型结构数组中：除了第一个元素外，每个元素都有一个直接的&quot;前驱元素&quot;。数组中：除了最后一个元素外，每个元素都有一个会直接的&quot;后继元素&quot;。 2.声明数组 123456789101.语法 1.var 数组名=[]; var names=[]; 2.var 数组名=[元素1,元素2,元素3...]; var names=[&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;]; 3.var 数组名=new Array(); var names=new Array(); 4.var 数组名=new Array(元素1，元素2...); var names=new Array(&quot;林黛玉&quot;,&quot;贾宝玉&quot;,&quot;王熙凤&quot;); 3.数组的使用 123456789101112131415161718192021221.取值和赋值操作 取值： 数组名[下标] var newArr=[&quot;tom&quot;,&quot;lilei&quot;]; newArr[0] 赋值： 数组名[下标]=值； newArr[2]=&quot;韩梅梅&quot;;2.获取数组的长度 数组长度：数组中元素的个数 属性：length 语法：数组名.length3.配合循环，遍历数组中的每个元素 for(var i=0;i&lt;names.length;i++){ i:表示数组中每个元素的下标 names[i]:每个元素 } length表示数组中即将要插入的元素的下标 var names=[&quot;tom&quot;,&quot;lili&quot;,&quot;lucy&quot;]; names[names.length]=&quot;lilei&quot;; 16.关联数组123456789101112131415161.关联数组 以字符串作为元素的下标的数组，就是关联数组。 以数字作为下标的数组，就是索引数组。$array=[&quot;name&quot;=&gt;&quot;tom&quot;]2.js中的关联数组 var array=[]; array[&quot;字符串下标&quot;]=值; 注意： 1.关联数组中，字符串下标的内容是不记录到length中的2.只能通过 字符串 做下标取值3.for...in 遍历出任意数组中的字符串下标 以及 索引下标 语法：for(var 变量 in 数组名){ //变量：字符串下标 或 索引下标 } 17.冒泡排序12345678910111213141516171819202122231.什么是冒泡 排序算法之一，将一组数据进行排序，小的数字往前排，大的数字往后排。 两两比较，小的靠前。 var arr=[9,23,6,78,45]; 5个数 比4轮 第一轮：比较了4次 第二轮：比较了3次 第三轮：比较了2次 第四轮：比较了1次 1.n个数字，则比较n-1轮 for(var i=1;i&lt;arr.length;i++) 2.轮数增加，比较的次数较少 for(var j=0;j&lt;arr.length-i;j++) 第一轮 5 -1=4次 第二轮 5 -2=3次 第三轮 5 -3=2次 第四轮 5 -4=1次 两两比较 小的靠前 if(arr[j]&gt;arr[j+1]) arr[j]^=arr[j+1]; arr[j+1]^=arr[j]; arr[j]^=arr[j+1] 18.数组的常用方法1.toString(); 12作用：将数组转换为字符串，并返回转换后的结果。语法： var str=数组对象.toString(); 2.join() 12作用：将数组的元素通过指定的字符连接到一起，并返回连接后字符串语法：var str=数组对象.join(&quot;字符&quot;); 3.concat() 123作用：拼接两个或更多的数组，并返回拼接后的结果语法：var res=数组对象.concat(数组1,数组2,...); 19.数组的函数1.slice() 12345678作用：截取子数组，从指定的数组中，截取几个连续的元素组成一个新的数组语法：var arr=数组名.slice(start,[end]); start:从哪个下标位置处开始截取，取值为正，从前向后算； 取值为负，从后向前算 0 1 2 var arr=[&quot;中国&quot;,&quot;美国&quot;,&quot;俄罗斯&quot;]; -3 -2 -1 end:指定结束位置处的下标（不包含自己），该参数可以省略， 如果省略的话，就是从strat开始一直截取到尾。 2.splice() 123456作用：允许从指定数组中，删除一部分元素，同时再添加一部分元素语法：arr.splice(start,count,e1,e2...); start:指定添加或删除元素的起始下标 count:指定要删除元素的个数，取值为0表示不删除 e1:要增加的新元素，可以多个 返回值：返回一个由删除元素所组成的数组 3.reverse() 123作用：将一个数组反转语法：数组名.reverse();注意：该函数会改变当前数组的内容 4.sort() 12345678910111213141516171819202122作用：排序，默认情况下按照数组元素们的Unicode码进行升序排序。语法：数组名.sort();特殊： 允许自定义排序函数，从而实现对数字的升序或降序的排序 ex: var arr=[12,6,4,115,78]; //排序函数（升序） function sortAsc(a,b){ return a-b; } arr.sort(sortAsc); 原理： 1.指定排序行数sortAsc，定义两个参数a和b，表示数组中相邻的两个数字2.将排序函数指定给数组sort()函数，数组会自动传递数据到sortAsc()中， 如果sortAsc()的返回值&gt;0，则交互两个数字的位置，否则不变。 使用函数完成升序排序： arr.sort( function(a,b){ //匿名函数 return a-b; } ) 20.进出栈操作JS是按照标准的“栈式操作”来访问数组所有的“栈式操作”的特点就是“后进先出”1.push() 1234入栈，在栈顶添加指定的元素，并返回新数组的长度 var arr=[10,20,30]; //向栈顶增加新的数据40 var len=arr.push(40); //4 2.pop() 12出栈，删除(删除栈顶数据)并返回删除元素注意：改变原来数组 3.shift() 12删除数组头部（第一个）的元素并返回删除元素语法：数组名.shift(); 4.unshift() 12在数组的头部（第一个）元素的位置处，增加元素,返回的是数组的长度。语法：数组名.unshift(增加的数据); 3.二维数组1.什么是二维数组 1在一个数组中的元素又是一个数组，也可以称为：数组的数组。 2.二维数组的使用 12345678var names=[ [&quot;孙悟空&quot;,&quot;猪八戒&quot;,&quot;沙和尚&quot;],[&quot;大乔&quot;,&quot;小乔&quot;,&quot;曹操&quot;],[&quot;林黛玉&quot;,&quot;贾宝玉&quot;,&quot;薛宝钗&quot;]]; //打印输出“小乔” console.log(names[1][1]);","link":"/2020/09/26/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93-JS%E5%9F%BA%E7%A1%80/"}],"tags":[],"categories":[{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"MarkDown","slug":"MarkDown","link":"/categories/MarkDown/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"BOM","slug":"BOM","link":"/categories/BOM/"},{"name":"微信小程序","slug":"微信小程序","link":"/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"}]}